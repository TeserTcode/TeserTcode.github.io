let bign = 10

      const knthetaa = [
	   math.complex(-0.4884150884437966033074145688009828070846452019933144110659203258, -0.9223068629260569360028235559934401714062536024757296551070286184),
    math.complex(0.003851578735411204420399364109394585843185019100299557939634370175, -0.09056477795411682044547667460610562297963243478659090786228987894),
    math.complex(0.002100916786902814872986655281733514148876424144705316994169658256, -0.03795624815247508554188893672201581077914536270451353672164745447),
    math.complex(0.001447547758421785120322056360837028884870406466145500301406390468, -0.02281729713002375502899972915432846601334842283056874647777022957),
    math.complex(0.001104386099212763734898482787823058366235237703064933600632173951, -0.01591997616942238837419345412868698280031768159954380825245251099),
    math.complex(0.0008925930993370412716687367311439146963311622539771580704880427279, -0.01205322305695692864975008563287107152522094862729950820040836599),
    math.complex(0.0007487739201806153049758044951052940118091071090206985765702546929, -0.009609109527693034937264641056222933237980714330290006089609899773),
    math.complex(0.0006447070675903776978488026882850743197145272531230651691592722707, -0.007937942295658218859174134769344880450697924795216699914435502927),
    math.complex(0.0005659061641790590181344669276728723138509004662004086543603548146, -0.006730015292187770054262275187965891901244389685431177911075154922),
    math.complex(0.0005041654941405862274307539927433877665937227700581003768123204892, -0.005820035931204927306224523286334754287263921141287385230243220755),
    math.complex(0.0004544872825132033722559396488552986529475881447380032450147114988, -0.005112199447745594893171793161203690360335197392328055217986417005),
    math.complex(0.0004136529004774918671618626459954724559749319620789536867370273260, -0.004547362107568092600925048536415649559078469627107748501527043503),
    math.complex(0.0003794955571786000088697356404197888286796467312410992883137925607, -0.004087146236240283999694668038068334966781507680882805358569200643),
    math.complex(0.0003505029366052633988576783626803309254052170161838436418100442001, -0.003705621564669216991707725572651167414285527654904302070911460098),
    math.complex(0.0003255873758339126954484586852188685668345673062105611875200235400, -0.003384671692770100003071703722399997866001801122288069938940601106),
    math.complex(0.0003039465587699662952802460548063685816196386198597183883266975190, -0.003111277707411010485372421696440090595171691803402175898505985212),
    math.complex(0.0002849756856682896456991292457736657318943935536589590646036775813, -0.002875856086155444352982526500791233294464529670378412454760636725),
    math.complex(0.0002682102094762768524805960805757221753676588577228413774263957149, -0.002671204038303480638933156368937704231533347407163452091644625313),
    math.complex(0.0002532874059782158978731245483184201725381761077080558628593401737, -0.002491809016411183393083725275197258343434499414580878869781449599),
    math.complex(0.0002399199252033383381531648506198264545555778190328086825557233190, -0.002333384176731953257491678245854568569465650215226605876827570224),
    math.complex(0.0002278771806878995978116431742754728195509773817572503488622253656, -0.002192548290134272888908485993937443480978253225566868373312073872),
    math.complex(0.0002169719939369601159275249206237052143958229041896684818458523502, -0.002066600468099710439973629868452944527075000424954282497730263613),
    math.complex(0.0002070508404320027768701131909127951364611663208110243110116426246, -0.001953358597288465093450281342794127932917952818195569992658696534),
    math.complex(0.0001979866127165430317589263437778081315770391674791140687674143941, -0.001851041486065535573407440218709946038702829744926764617624524757),
    math.complex(0.0001896731739394399866788397399722925496477110933666346439184319091, -0.001758181572182321112069035868202704103950291218436861667237033803),
    math.complex(0.0001820212054891074112044000129667354213978538196316436387851418153, -0.001673559363676357346123914971694493232221993735550917268738858015),
    math.complex(0.0001749550036403234273399494570255873164165031785568179628977463350, -0.001596153575767860240554422661364695866209785232138170351272344324),
    math.complex(0.0001684099814472925376319239927522230783547847964370519880770944165, -0.001525102764611534750326461986800943694890299622654514619465599691),
    math.complex(0.0001623307011478848943909394080050075970092093527506422409448875742, -0.001459675491716838194338653559325080973844923375620283682405507015),
    math.complex(0.0001566693101331199909220087635208187462749090936893864569163060912, -0.001399246893842371680401845259694777305087674295472373168470742488),
    math.complex(0.0001513842871063078569145807647799539359116309132963533158941501613, -0.001343280115689140884621279080849079857285062807417072217432552249),
    math.complex(0.0001464394289583394447247721734079990890418841145303703492639726523, -0.001291311471960750653908059196955788990876691029817777927299295301),
    math.complex(0.0001418030261175519151211374693074145618328214714132123674328852046, -0.001242938496662146649073428500230412148743921407926676370817938625),
    math.complex(0.0001374471867005090255770591229055772697473198870561426235043644986, -0.001197810247398746352496354555014575959958941477123993056349877833),
    math.complex(0.0001333472790556910966327361100265556812492078690586265155692217148, -0.001155619385389272268060593618510539536991738480079500511828080918),
    math.complex(0.0001294814691922701317867561720255548440064688994206315412051196830, -0.001116095664547526248761287482063258310060801470527987525823350702),
    math.complex(0.0001258303347733657589577696402821961482772193213496719530033342190, -0.001079000546767080135716869093687333252602486146227271121757786628),
    math.complex(0.0001223765412872603325844486349523649156478358427628515269312269217, -0.001044122723433417190447027562677345959300221153348646809655905036),
    math.complex(0.0001191045690185864086090848447251650999256128429514119094164733358, -0.001011274370810359250781122540766279539538009204729341031155331676),
    math.complex(0.0001160004817602718618354116842527507791605150799581783350152968306, -0.0009802880033044178563593392930984679209828927175383392734733906396),
    math.complex(0.0001130517300073879111072767284551504870621327179773008393992382167, -0.0009510138165816972450739097696802100090600073882148206829811154926),
    math.complex(0.0001102469827816539431837410946157009444326178175090307918324902937, -0.0009233174341885346365203266236251432785676054628360253910615663766),
    math.complex(0.0001075759833431574905260456706989882600017816184441893789020826951, -0.0008970779882416688038811024000686339628261525062030174427210974300),
    math.complex(0.0001050294249231578405642745349518431116052669169413568861682665806, -0.0008721864780388293730799063194368000970158752795298437540522459254),
    math.complex(0.0001025988433107396714750408090263878426401045584210167310049468416, -0.0008485443609397825491565516344777714454522808512310834878335860130),
    math.complex(0.0001002765236859915805823982965486242105602111831573035932129209353, -0.0008260623382141759381895854390136442828610870208222580896984706258),
    math.complex(9.805541954335107556324438591529765967978181036847202876136258659e-5, -0.0008046593052246129637638310317170863565167375978846896286659291607),
    math.complex(9.592908191383587247204947195050685442544549439245568950225529990e-5, -0.0007842614406755552606690419022963891465180397687979920940843385186),
    math.complex(9.389159739186952256957537926879213215977706219995989054216302302e-5, -0.0007648014139899961858380046660772991544361372347914815520642298214),
    math.complex(9.193753371513106628768806391406014126734138226459751564223391282e-5, -0.0007462176933915225570310056169433131276648201124332129077993072937),
    math.complex(9.006189184511152140135588682959610869089924558110295376009770450e-5, -0.0007284539401362281596641263543272122555174319700177155323135572269),
    math.complex(8.826006366032518850846828920720607759342574182666599716365528031e-5, -0.0007114584766870765590820275163454576039804465378854442997108964844),
    math.complex(8.652779451009647244146107135028422719721639560788412348040297121e-5, -0.0006951838185547548458429913496862294190872705135690895971283074639),
    math.complex(8.486114998983572209736604208301551440602875634950903180956943719e-5, -0.0006795862611242247247425102779266978505071797128401770548166079157),
    math.complex(8.325648639296596995426728981234729804875179263959087830500981804e-5, -0.0006646255141087549026170734385955154722958533657139322473022881236),
    math.complex(8.171042437355873275702681738258431113430986989946275120293151168e-5, -0.0006502643773738992321254237374188328257557423025199083328327748489),
    math.complex(8.021982542001023415497760346840762752972488288470446407612314855e-5, -0.0006364684527931956964094497175999908017813283732862787317225164460),
    math.complex(7.878177079594425393460935845311850634874468352218878086163471706e-5, -0.0006232058875678463155090833893033917095631649053988665236741414772),
    math.complex(7.739354265175272528970095315565445449395583976404287782752869924e-5, -0.0006104471450905416745750599567035079243225218491958892623830844473),
    math.complex(7.605260705023662591683674215491958711194575443441659148758242520e-5, -0.0005981647999801659300901133780805430707771024544719758191290647784)
];

function integral(func, initial, end, input, N = bign) {
    // Function to handle complex integration
    function simpsonsRule(a, b, n) {
        const h = math.divide(math.subtract(b, a), n);
        let sum = math.complex(0,0);
        
        for (let i = 1; i < n; i += 2) {
            sum = math.add(sum, math.multiply(math.complex(4,0), func(math.add(a, math.multiply(math.complex(i,0), h)), input)));
        }
        
        for (let i = 2; i < n - 1; i += 2) {
            sum = math.add(sum, math.multiply(math.complex(2,0), func(math.add(a, math.multiply(math.complex(i,0), h)), input)));
        }
        
        return math.multiply(math.divide(h, math.complex(3,0)), sum);
    }

    // Adaptive Simpson's rule to ensure convergence
          return simpsonsRule(initial,end, N);
       }

let randc = math.complex(2.1723687,1.8278742);
function eulerc () { return math.complex(2.71828,0);        
}
function log(x){return math.log(x);}
function sinc(z) {
            if (math.abs(z) === 0) {
                return math.complex(1, 0);
            }
            return math.divide(math.sin(z), z);
        }
// Function for the 'taxicab' operation
function taxicab(b) {
    const xf = b.re;
    const yf = b.im;
    const ss = Math.sqrt(xf * xf + yf * yf);
    const ata = Math.atan2(yf, xf);
    return math.complex(
        ss * ((Math.abs((ata + 10 * Math.PI) % (2 * Math.PI) - Math.PI) / (Math.PI / 2)) - 1),
        ss * ((Math.abs((ata - Math.PI / 2 + 10 * Math.PI) % (2 * Math.PI) - Math.PI) / (Math.PI / 2)) - 1)
    );
}

// Function for the 'arctaxicab' operation
function arctaxicab(b) {
    const xf = b.re;
    const yf = b.im;
    const ss = Math.sqrt(xf * xf + yf * yf);
    const ata = Math.atan2(yf, xf);
    return math.complex(
        ss * (Math.cos(ata) * Math.cos(ata) / ((Math.abs((ata + 10 * Math.PI) % (2 * Math.PI) - Math.PI) / (Math.PI / 2)) - 1)),
        ss * (Math.sin(ata) * Math.sin(ata) / ((Math.abs((ata - Math.PI / 2 + 10 * Math.PI) % (2 * Math.PI) - Math.PI) / (Math.PI / 2)) - 1))
    );
}

// Function for the 'chebyshev' operation
function chebyshev(b) {
    const xf = b.re;
    const yf = b.im;
    const ss = Math.sqrt(xf * xf + yf * yf);
    const ata = Math.atan2(yf, xf);
    return math.complex(
        ss * Math.max(-1, Math.min(1, Math.tan((Math.abs((ata + 10 * Math.PI) % (2 * Math.PI) - Math.PI) / (Math.PI / 2)) - 1))),
        ss * Math.max(-1, Math.min(1, Math.tan((Math.abs((ata - Math.PI / 2 + 10 * Math.PI) % (2 * Math.PI) - Math.PI) / (Math.PI / 2)) - 1)))
    );
}

// Function for the 'arcchebyshev' operation
function arcchebyshev(b) {
    const xf = b.re;
    const yf = b.im;
    const ss = Math.sqrt(xf * xf + yf * yf);
    const ata = Math.atan2(yf, xf);
    return math.complex(
        ss * (Math.cos(ata) * Math.cos(ata) / Math.max(-1, Math.min(1, Math.tan((Math.abs((ata + 10 * Math.PI) % (2 * Math.PI) - Math.PI) / (Math.PI / 2)) - 1)))),
        ss * (Math.sin(ata) * Math.sin(ata) / Math.max(-1, Math.min(1, Math.tan((Math.abs((ata - Math.PI / 2 + 10 * Math.PI) % (2 * Math.PI) - Math.PI) / (Math.PI / 2)) - 1))))
    );
}


// Function for 'powcos'
function powcos(a, b) {
    return math.multiply(math.pow(a, b), math.cos(a));
}

// Function for 'powsin'
function powsin(a, b) {
    return math.multiply(math.pow(a, b), math.sin(a));
}



// Function for 'exp+'
function expPlus(a, b) {
    return math.add(a, math.exp(b));
}

// Function for 'exp2'
function exp2( b) {
    return  math.pow(2, b);
}

// Function for 'exp10'
function exp10( b) {
    return  math.pow(10, b);
}


// Function for 'expc'
function expc(a, b) {
    return math.divide(math.exp(b), math.pow(b, a));
}

// Function for 'expi'
function expi( b) {
    return math.divide(1, math.exp(b));
}

// Function for 'expic'
function expic( b) {
    return  math.multiply(math.exp(b), math.add(b, 0.0001));
}

// Function for 'expein'
function expein(b) {
    return math.divide(math.subtract(1.0, math.exp(math.unaryMinus(b))), math.add(b, 0.0001));
}

// Function for 'expsqr'
function expsqr( b) {
    return  math.exp(math.multiply(b, b));
}

// Function for 'expmsqr'
function expmsqr( b) {
    return math.add(math.exp(math.unaryMinus(math.multiply(b, b))), 0.0001);
}

// Function for 'log-1'
function logMinus1(b) {
    return math.divide(1.0, math.log(b));
}



// Function for 'log10'
function log10( b) {
    return  math.log(b, 10.0);
}

// Function for '_log'
function _log(b, a) {
    return math.log(b, a);
}

// Function for 'antilog'
function antilog(b) {
    return math.log(b, math.e);
}

// Function for 'antilog2'
function antilog2(b) {
    return math.log(b, 2.0);
}

// Function for 'antilog10'
function antilog10(b) {
    return math.log(b, 10.0);
}

// Function for 'logc'
function logc(b) {
    return math.divide(math.log(b), b);
}

// Function for 'naplog'
function naplog(b) {
    return math.multiply(-10000000.0, math.log(math.divide(b, 10000000.0)));
}

// Function for 'dist'
function dist(a, b) {
    return math.add(math.multiply(a, a), math.multiply(b, b));
}

// Function for 'hypot'
function hypot(a, b) {
    return math.sqrt(math.add(math.multiply(a, a), math.multiply(b, b)));
}

// Function for 'sdist'
function sdist(a, b) {
    return math.subtract(math.multiply(a, a), math.multiply(b, b));
}

// Function for 'zdist'
function zdist(b) {
    return math.divide(math.distz(b));
}

// Utility function for degrees to radians
function degreesToRadians(deg) {
    return math.multiply(deg, math.pi / 180);
}

// Utility function for radians to degrees
function radiansToDegrees(rad) {
    return math.multiply(rad, 180 / math.pi);
}

// Function for 'ramp'
function ramp(a, b) {
    return math.multiply(a, math.mod(b, 2 * math.pi) / math.pi - 1.0);
}

// Function for 'squarewave'
function squarewave(a, b) {
    return math.multiply(a, math.lessThan(math.mod(b, 2 * math.pi), math.pi) ? 1.0 : -1.0);
}

// Function for 'trianglewave'
function trianglewave(a, b) {
    return math.multiply(a, math.multiply(2.0 / math.pi, math.asin(math.sin(b))));
}

// Function for 'sawtoothwave'
function sawtoothwave(a, b) {
    return math.multiply(a, math.multiply(2.0 / math.pi, math.subtract(math.pi, math.mod(b, 2 * math.pi))));
}

// Function for 'pulse'
function pulse(a, b) {
    return math.multiply(a, math.sin(b) > 0 ? 1.0 : -1.0);
}

// Function for 'todeg'
function todeg(b) {
    return radiansToDegrees(b);
}

// Function for 'sind'
function sind(a, b) {
    return math.multiply(a, math.sin(degreesToRadians(b)));
}

// Function for 'sinhdeg'
function sinhdeg(a, b) {
    return math.multiply(a, math.sinh(degreesToRadians(b)));
}

// Function for 'asind'
function asind(a, b) {
    return radiansToDegrees(math.multiply(a, math.asin(b)));
}

// Function for 'cosd'
function cosd(a, b) {
    return math.multiply(a, math.cos(degreesToRadians(b)));
}

// Function for 'coshdeg'
function coshdeg(a, b) {
    return math.multiply(a, math.cosh(degreesToRadians(b)));
}

// Function for 'acosd'
function acosd(a, b) {
    return radiansToDegrees(math.multiply(a, math.acos(b)));
}

// Function for 'tand'
function tand(a, b) {
    return math.multiply(a, math.tan(degreesToRadians(b)));
}

// Function for 'tanhdeg'
function tanhdeg(a, b) {
    return math.multiply(a, math.tanh(degreesToRadians(b)));
}

// Function for 'atand'
function atand(a, b) {
    return radiansToDegrees(math.multiply(a, math.atan(b)));
}

// Function for 'atan2d'
function atan2d(a, b) {
    return radiansToDegrees(math.atan(math.divide(a, b)));
}
function cot(b) {
    return math.divide(math.complex(1), math.tan(b));
}

// Function for 'coth'
function coth(b) {
    return math.divide(math.complex(1), math.tanh(b));
}

// Function for 'sec'
function sec(b) {
    return math.divide(math.complex(1), math.cos(b));
}

// Function for 'sech'
function sech(b) {
    return math.divide(math.complex(1), math.cosh(b));
}

// Function for 'csc'
function csc(b) {
    return math.divide(math.complex(1), math.sin(b));
}

// Function for 'csch'
function csch(b) {
    return math.divide(math.complex(1), math.sinh(b));
}

// Function for 'crd'
function crd(b) {
    return math.multiply(math.sin(math.divide(b, math.complex(2))), math.complex(2));
}

// Function for 'arccrd'
function arccrd(b) {
    return math.multiply(math.asin(math.divide(b, math.complex(2))), math.complex(2));
}

// Function for 'arccrdd'
function arccrdd(b) {
    return radiansToDegrees(math.multiply(math.asin(math.divide(b, math.complex(2))), math.complex(2)));
}

// Function for 'asinh'
function asinh(b) {
    return math.asinh(b);
}

// Function for 'acosh'
function acosh(b) {
    return math.acosh(b);
}

// Function for 'atanh'
function atanh(b) {
    return math.atanh(b);
}

// Function for 'asec'
function asec(b) {
    return math.acos(math.divide(math.complex(1), b));
}

// Function for 'asech'
function asech(b) {
    return math.acosh(math.divide(math.complex(1), b));
}

// Function for 'acsc'
function acsc(b) {
    return math.asin(math.divide(math.complex(1), b));
}

// Function for 'acsch'
function acsch(b) {
    return math.asinh(math.divide(math.complex(1), b));
}

// Function for 'exsec'
function exsec(b) {
    return math.subtract(math.sec(b), math.complex(1));
}

// Function for 'excosec'
function excosec(b) {
    return math.subtract(math.csc(b), math.complex(1));
}

// Function for 'versin'
function versin(b) {
    return math.subtract(math.complex(1), math.cos(b));
}

// Function for 'vercosin'
function vercosin(b) {
    return math.add(math.complex(1), math.cos(b));
}

// Function for 'coversin'
function coversin(b) {
    return math.subtract(math.complex(1), math.sin(b));
}

// Function for 'covercosine'
function covercosine(b) {
    return math.add(math.complex(1), math.sin(b));
}

// Function for 'haversin'
function haversin(b) {
    return math.multiply(math.subtract(math.complex(1), math.cos(b)), math.complex(0.5));
}

// Function for 'hacovercosin'
function hacovercosin(b) {
    return math.multiply(math.add(math.complex(1), math.sin(b)), math.complex(0.5));
}

// Function for 'arcversin'
function arcversin(b) {
    return math.acos(math.subtract(math.complex(1), b));
}

// Function for 'arcvercos'
function arcvercos(b) {
    return math.acos(math.subtract(b, math.complex(1)));
}

// Function for 'arccoversin'
function arccoversin(b) {
    return math.asin(math.subtract(math.complex(1), b));
}

// Function for 'arccovercos'
function arccovercos(b) {
    return math.asin(math.subtract(b, math.complex(1)));
}

// Function for 'archaversin'
function archaversin(b) {
    return math.multiply(math.complex(2), math.asin(math.sqrt(b)));
}

// Function for 'archavercos'
function archavercos(b) {
    return math.multiply(math.complex(2), math.acos(math.sqrt(b)));
}

// Function for 'archacoversin'
function archacoversin(b) {
    return math.asin(math.subtract(math.complex(1), math.multiply(math.complex(2), b)));
}

// Function for 'archacovercos'
function archacovercos(b) {
    return math.asin(math.subtract(math.multiply(math.complex(2), b), math.complex(1)));
}

// Function for 'sinsqr'
function sinsqr(b) {
    return math.multiply(math.sin(math.multiply(b, b)), math.complex(1));
}

// Function for 'cossqr'
function cossqr(b) {
    return math.multiply(math.cos(math.multiply(b, b)), math.complex(1));
}

// Function for 'shid'
function shid(b) {
    return math.divide(math.sinh(b), math.add(b, math.complex(0.0001)));
}

// Function for 'cosh-1'
function coshminus1(b) {
    return math.divide(math.complex(1), math.cosh(b));
}

// Function for 'sinc'
function sinc(b) {
    return math.divide(math.sin(b), math.add(b, math.complex(0.0001)));
}

// Function for 'cosc'
function cosc(b) {
    return math.divide(math.cos(b), math.add(b, math.complex(0.0001)));
}

// Function for 'coshc'
function coshc(b) {
    return math.divide(math.cosh(b), math.add(b, math.complex(0.0001)));
}

// Function for 'sinhc'
function sinhc(b) {
    return math.divide(math.sinh(b), math.add(b, math.complex(0.0001)));
}

// Function for 'tanc'
function tanc(b) {
    return math.divide(math.tan(b), math.add(b, math.complex(0.0001)));
}

// Function for 'tanhc'
function tanhc(b) {
    return math.divide(math.tanh(b), math.add(b, math.complex(0.0001)));
}

// Function for 'asinc'


// Function for 'acoshc'
function acoshc(b) {
    return math.divide(math.cosh(b), math.add(b, math.complex(0.0001)));
}

// Function for 'asinhc'
function asinhc(b) {
    return math.divide(math.sinh(b), math.add(b, math.complex(0.0001)));
}

// Function for 'atanhc'
function atanhc(b) {
    return math.divide(math.tanh(b), math.add(b, math.complex(0.0001)));
}
function complex(value) {
    return math.complex(value, 0);
}

// Function for 'cis'
function cis(b) {
    return math.multiply(complex(1), math.add(math.multiply(math.cos(b), complex(1, 0)), math.multiply(math.sin(b), complex(0, 1))));
}

// Function for 'cas'
function cas(b) {
    return math.add(math.multiply(math.sin(b), complex(1)), math.multiply(math.cos(b), complex(1)));
}

// Function for 'cish'
function cish(b) {
    return math.add(math.multiply(math.cosh(b), complex(1, 0)), math.multiply(math.sinh(b), complex(0, 1)));
}

// Function for 'sich'
function sich(b) {
    return math.add(math.multiply(math.sinh(b), complex(1, 0)), math.multiply(math.cosh(b), complex(0, 1)));
}

// Function for 'cisc'
function cisc(b) {
    return math.divide(math.multiply(math.cos(b), complex(0, 1)), b);
}

// Function for 'casc'
function casc(b) {
    return math.divide(math.add(math.sin(b), math.cos(b)), b);
}

// Function for 'cishc'
function cishc(b) {
    return math.divide(math.multiply(math.cosh(b), complex(0, 1)), b);
}

// Function for 'sichc'
function sichc(b) {
    return math.divide(math.multiply(math.sinh(b), complex(0, 1)), b);
}

// Function for 'sinp'
function sinp(b) {
    return math.multiply(2.0, math.sinh(math.divide(math.asinh(math.divide(math.subtract(math.multiply(3.0, b), 4.0), 2.0)), 3.0)));
}

function cosp(b) {
    const term = math.cosh(math.multiply(math.divide(2.0, 3.0), math.asinh(math.divide(math.subtract(math.multiply(3.0, b), 4.0), 2.0))));
    return math.multiply(math.subtract(3.0, math.multiply(2.0, term)), complex(1));
}

// Function for 'tanp'
function tanp(b) {
    const asinhTerm = math.asinh(math.divide(math.subtract(math.multiply(3.0, b), 4.0), 2.0));
    const sinhTerm = math.sinh(math.multiply(math.divide(1.0, 3.0), asinhTerm));
    const coshTerm = math.cosh(math.multiply(math.divide(2.0, 3.0), asinhTerm));
    return math.divide(sinhTerm, math.subtract(3.0, math.multiply(2.0, coshTerm)));
}

// Function for 'cscp'
function cscp(b) {
    const asinhTerm = math.asinh(math.divide(math.subtract(math.multiply(3.0, b), 4.0), 2.0));
    const sinhTerm = math.sinh(math.multiply(math.divide(1.0, 3.0), asinhTerm));
    return math.divide(complex(1), math.multiply(2.0, sinhTerm));
}

// Function for 'secp'
function secp(b) {
    const asinhTerm = math.asinh(math.divide(math.subtract(math.multiply(3.0, b), 4.0), 2.0));
    const coshTerm = math.cosh(math.multiply(math.divide(2.0, 3.0), asinhTerm));
    return math.divide(complex(1), math.subtract(3.0, math.multiply(2.0, coshTerm)));
}

// Function for 'cotp'
function cotp(b) {
    const asinhTerm = math.asinh(math.divide(math.subtract(math.multiply(3.0, b), 4.0), 2.0));
    const sinhTerm = math.sinh(math.multiply(math.divide(1.0, 3.0), asinhTerm));
    const coshTerm = math.cosh(math.multiply(math.divide(2.0, 3.0), asinhTerm));
    return math.divide(sinhTerm, coshTerm);
}

// Function for 'asinp'
function asinp(b) {
    const asinhTerm = math.asinh(math.divide(b, 2.0));
    return math.multiply(math.divide(math.add(math.multiply(2.0, math.sinh(math.multiply(asinhTerm, 3.0))), 4.0), 3.0), complex(1));
}

// Function for 'acosp'
function acosp(b) {
    const acoshTerm = math.acosh(math.divide(math.subtract(3.0, b), 2.0));
    return math.multiply(math.divide(math.add(math.multiply(2.0, math.sinh(math.multiply(acoshTerm, math.divide(3.0, 2.0)))), 4.0), 3.0), complex(1));
}

// Function for 'acscp'
function acscp(b) {
    const asinhTerm = math.asinh(math.divide(complex(1.0), b));
    return math.multiply(math.divide(math.add(math.multiply(2.0, math.sinh(math.multiply(asinhTerm, 3.0))), 4.0), 3.0), complex(1));
}

// Function for 'asecp'
function asecp(b) {
    const acoshTerm = math.acosh(math.divide(math.subtract(3.0, math.divide(complex(1.0), b)), 2.0));
    return math.multiply(math.divide(math.add(math.multiply(2.0, math.sinh(math.multiply(acoshTerm, math.divide(3.0, 2.0)))), 4.0), 3.0), complex(1));
}


function arithmeticmean(a, b) {
    return math.divide(math.add(a, b), complex(2.0));
}

function geometricmean(a, b) {
    return math.sqrt(math.multiply(a, b));
}

function arithmeticgeometricmean(a, b) {
    // Implement the AG method here
    // Placeholder for AG function
}

function arithmeticharmonicmean(a, b) {
    const harmonicMean1 = math.divide(complex(1.0), math.add(math.divide(complex(1.0), a), math.divide(complex(1.0), ari(a, b))));
    const harmonicMean2 = math.divide(complex(1.0), math.add(math.divide(complex(1.0), a), math.divide(complex(1.0), ari(a, b))));
    return ari(harmonicMean1, harmonicMean2);
}

function geometricharmonicmean(a, b) {
    const harmonicMean1 = math.divide(complex(1.0), math.add(math.divide(complex(1.0), a), math.divide(complex(1.0), geo(a, b))));
    const harmonicMean2 = math.divide(complex(1.0), math.add(math.divide(complex(1.0), a), math.divide(complex(1.0), geo(a, b))));
    return geo(harmonicMean1, harmonicMean2);
}

function harmonicmean(a, b) {
    return math.divide(complex(1.0), math.add(math.divide(complex(1.0), a), math.divide(complex(1.0), b)));
}

function quadraticmean(a, b) {
    return pow(math.add(pow(a, complex(2.0)), pow(b, complex(2.0))), complex(1.0 / 2.0));
}

function cubicmean(a, b) {
    return pow(math.add(pow(a, complex(3.0)), pow(b, complex(3.0))), complex(1.0 / 3.0));
}

function heronianmean(a, b) {
    return math.divide(math.add(math.add(a, b), sqrt(math.multiply(a, b))), complex(3.0));
}

function contraharmonicmean(a, b) {
    const numerator = ari(pow(a, complex(2.0)), pow(b, complex(2.0)));
    const denominator = ari(a, b);
    return math.divide(numerator, denominator);
}

function neumansandormean(a, b) {
    const numerator = math.subtract(a, b);
    const denominator = math.multiply(complex(2.0), asinh(math.divide(math.subtract(a, b), math.add(a, b))));
    return math.divide(numerator, denominator);
}

function neumansandortmean(a, b) {
    const numerator = math.subtract(a, b);
    const denominator = math.multiply(complex(2.0), atan(math.divide(math.subtract(a, b), math.add(a, b))));
    return math.divide(numerator, denominator);
}

function rootmean(a, b) {
    return sqrt(ari(pow(a, complex(2.0)), pow(b, complex(2.0))));
}

function logarithmicmean(a, b) {
    return math.divide(math.subtract(a, b), math.subtract(log(a), log(b)));
}

function identricmean(a, b) {
    return pow(math.divide(pow(a, a), pow(b, b)), math.divide(complex(1.0), math.subtract(a, b))) / eulerc;
}

function tocomp(value) {
    return math.complex(value);
}

function conj(value) {
    return math.complex(value).conjugate();
}

function arg(value) {
    return math.arg(tocomp(value));
}

function proj(value) {
    return math.multiply(tocomp(value), math.divide(tocomp(value), math.abs(tocomp(value))));
}

function signum(value) {
    const absValue = math.abs(value);
    return math.divide(value, absValue);
}

// Complex operations
function dot(a, b) {
    const aComp = tocomp(a);
    const bComp = tocomp(b);
    return math.add(math.multiply(aComp.re, bComp.re), math.multiply(aComp.im, bComp.im));
}

function cross(a, b) {
    const aComp = tocomp(a);
    const bComp = tocomp(b);
    return math.subtract(math.multiply(aComp.re, bComp.im), math.multiply(aComp.im, bComp.re));
}

function mandel(a, b) {
    const c = tocomp(b);
    const z = tocomp(a);
    return math.add(math.multiply(z, z), c);
}

function conjOp(b) {
    return conj(b);
}

function argOp(b) {
    return arg(b);
}

function im(b) {
    return tocomp(b).im;
}

function re(b) {
    return tocomp(b).re;
}

function dex(b) {
    return pow(complex(10.0), b);
}

function doubleexp(b) {
    return math.exp(math.exp(b));
}

function logOp(a, b) {
    return math.multiply(a, log(b));
}

function logPlus(a, b) {
    return math.add(a, log(b));
}

function logp(b) {
    return math.add(log(b), complex(1.0));
}

function logpc(b) {
    return math.divide(math.add(log(b), complex(1.0)), b);
}

function colog(b) {
    return log(math.divide(complex(1.0), b));
}

function cbrt(b) {
    return pow(b, complex(1.0 / 3.0));
}

function rabs(b) {
    return math.complex(math.abs(tocomp(b).re), tocomp(b).im);
}

function iabs(b) {
    return math.complex(tocomp(b).re, math.abs(tocomp(b).im));
}

function cabs(b) {
    return math.complex(math.abs(tocomp(b).re), math.abs(tocomp(b).im));
}

function sabs(b) {
    return sqrt(math.add(math.multiply(b, b), complex(0.0)));
}

function norm(b) {
    return math.multiply(math.abs(b), math.abs(b));
}

function real(b) {
    return tocomp(b).re;
}

function imag(b) {
    return tocomp(b).im;
}

function vdot(a, b) {
    return math.multiply(conj(tocomp(a)), b);
}

function vcross(a, b) {
    return math.multiply(a, conj(b));
}

function mag(b) {
    return math.abs(b);
}

function angle(b) {
    return arg(b);
}

function unit(b) {
    return math.divide(b, math.abs(b));
}

function signumOp(a, b) {
    return math.multiply(a, signum(tocomp(b).re));
}

// Helper functions
function maxc(a, b) {
    return math.max(a, b);
}

function minc(a, b) {
    return math.min(a, b);
}

function toDouble(value) {
    return Number(value);
}

function toComplex(value) {
    return math.complex(value);
}

function rand() {
    return Math.random(); // Generates a random float between 0 and 1
}

// Main operations
function sqr(b) {
    return math.multiply(b, b);
}

function sqrm(b) {
    return math.subtract(math.multiply(b, b), 1.0);
}

function cum(b) {
    return math.multiply(b, math.multiply(b, b));
}

function cumm(b) {
    return math.subtract(math.multiply(b, math.multiply(b, b)), 1.0);
}

function fz(b) {
    return math.pow(b, b);
}

function qnum(a, b) {
    return math.divide(math.subtract(1.0, math.pow(b, a)), math.subtract(1.0, b));
}

function regularInteriorAngle(b) {
    return math.multiply(math.subtract(b, 2.0), 180.0 / b);
}

function regularExteriorAngle(b) {
    return 360.0 / b;
}

function regularApothem(a, b) {
    return math.divide(a, math.multiply(2.0, math.tan(math.pi / b)));
}

function regularArea(a, b) {
    return math.multiply(0.5, math.multiply(a, math.multiply(b, math.tan(math.pi / b))));
}

function average(a, b) {
    return math.divide(math.add(a, b), 2.0);
}

function clamp(a, b) {
    const lower = 0.0;
    const upper = maxc(a, b);
    return maxc(lower, minc(b, upper));
}

function step(a, b) {
    return toDouble(b) < 0 ? 0 : a;
}

function hstep(a, b) {
    return toDouble(b) < toDouble(a) ? 0 : 1;
}

function ustep(a, b) {
    if (toDouble(b) < 0) return 0;
    if (math.equal(tocomplex(b), tocomplex(0))) return math.divide(a, 2.0);
    return a;
}

function hustep(a, b) {
    if (toDouble(b) < toDouble(a)) return 0;
    if (math.equal(b, a)) return 0.5;
    return 1;
}

function sqrt(a, b) {
    return math.multiply(a, math.sqrt(b));
}

function ceiling(b) {
    return math.ceil(b);
}

function round(b) {
    return math.round(b);
}

function absolute(b) {
    return math.abs(b);
}

function floor(b) {
    return math.floor(b);
}

function randomInteger(a, b) {
    return math.add(math.mod(math.multiply(rand(), math.round(b - a + 1)), math.round(b - a + 1)), math.round(a));
}

function randomFloat(a, b) {
    return math.add(a, math.multiply(rand(), math.subtract(b, a)));
}

// Helper functions
function toComplex(value) {
    return math.complex(value);
}

// Main operations
function cullen(b) {
    return math.add(math.multiply(b, math.pow(toComplex(2.0), b)), toComplex(1.0));
}

function mersenne(b) {
    return math.subtract(math.pow(toComplex(2.0), b), toComplex(1.0));
}

function doubleMersenne(b) {
    return math.subtract(math.pow(toComplex(2.0), math.subtract(math.pow(toComplex(2.0), b), toComplex(1.0))), toComplex(1.0));
}

function doublePrimeMersenne(b) {
    return math.subtract(math.pow(toComplex(2.0), math.subtract(math.pow(toComplex(2.0), nthPrime(b)), toComplex(1.0)))), toComplex(1.0);
}

function fermat(b) {
    return math.add(math.pow(toComplex(2.0), math.pow(toComplex(2.0), b)), toComplex(1.0));
}

function fermatPrime(b) {
    return fermatPrimeList[Math.max(parseInt(toDouble(b)), 4)]; // Example, update with actual list
}

function proth(a, b) {
    return math.add(math.multiply(a, math.pow(toComplex(2.0), b)), toComplex(1.0));
}

function isProthPrime(a, b) {
    return isPrime(math.add(math.multiply(a, math.pow(toComplex(2.0), b)), toComplex(1.0)));
}

function thabit(b) {
    return math.subtract(math.multiply(toComplex(3.0), math.pow(toComplex(2.0), b)), toComplex(1.0));
}

function thabit2(b) {
    return math.add(math.multiply(toComplex(3.0), math.pow(toComplex(2.0), b)), toComplex(1.0));
}

function woodall(b) {
    return math.subtract(math.multiply(b, math.pow(toComplex(2.0), b)), toComplex(1.0));
}

function genWoodall(a, b) {
    return math.subtract(math.multiply(b, math.pow(a, b)), toComplex(1.0));
}

function isGenWoodallPrime(a, b) {
    return isPrime(math.subtract(math.multiply(b, math.pow(a, b)), toComplex(1.0)));
}

function hilbert(b) {
    return math.add(math.multiply(toComplex(4.0), b), toComplex(1.0));
}

function idoneal(b) {
    return idonealList[Math.max(parseInt(toDouble(b)), 65)]; // Example, update with actual list
}

function leyland(a, b) {
    return math.add(math.pow(a, b), math.pow(b, a));
}

function loschian(a, b) {
    return math.add(math.add(math.pow(a, toComplex(2.0)), math.multiply(a, b)), math.pow(b, toComplex(2.0)));
}

function jacobsthal(b) {
    return math.divide(math.subtract(math.pow(toComplex(2.0), b), math.cos(math.multiply(math.pi, b))), toComplex(3.0));
}

function jacobsthallucas(b) {
    return math.subtract(math.pow(toComplex(2.0), b), math.cos(math.multiply(math.pi, b)));
}

function jacobsthaloblong(b) {
    return jacobsthalOblong(b); // Example, update with actual function
}



function pell(b) {
    return math.divide(math.subtract(math.pow(math.add(toComplex(1.0), math.sqrt(toComplex(2.0))), b), math.multiply(math.pow(math.add(toComplex(1.0), math.sqrt(toComplex(2.0))), math.negate(b)), math.cos(math.multiply(math.pi, b)))), math.multiply(math.sqrt(toComplex(2.0)), toComplex(2.0)));
}

function pellLucas(b) {
    return math.divide(math.subtract(math.pow(math.add(toComplex(1.0), math.sqrt(toComplex(2.0))), b), math.multiply(math.pow(math.add(toComplex(1.0), math.sqrt(toComplex(2.0))), math.negate(b)), math.cos(math.multiply(math.pi, b)))), math.multiply(math.sqrt(toComplex(2.0)), toComplex(2.0)));
}



function fibonacci(b) {
    return math.divide(math.subtract(math.pow(toComplex(1.61803399), b), math.multiply(math.pow(toComplex(1.61803399), math.negate(b)), math.cos(math.multiply(math.pi, b)))), math.sqrt(toComplex(5.0)));
}

function lucas(b) {
    return math.subtract(math.pow(toComplex(1.61803399), b), math.multiply(math.pow(toComplex(1.61803399), math.negate(b)), math.cos(math.multiply(math.pi, b))));
}


function orientedTree(b) {
    return math.round(math.multiply(toComplex(0.22571615379282714232305), math.divide(math.pow(toComplex(5.64654261623294971289271351621), b), math.pow(b, math.divide(toComplex(5.0), toComplex(2.0))))));
}

function magic(b) {
    return math.multiply(toComplex(2.0), math.add(nCr(b, toComplex(1.0)), math.add(nCr(b, toComplex(2.0)), nCr(b, toComplex(3.0)))));
}

function magicConst(b) {
    return math.divide(math.multiply(b, math.add(math.pow(b, toComplex(2.0)), toComplex(1.0))), toComplex(2.0));
}

function alucin(b) {
    return math.divide(math.divide(math.pow(b, toComplex(3.0))), math.multiply(math.subtract(toComplex(1.0), math.pow(b, toComplex(2.0))), math.multiply(math.subtract(toComplex(1.0), math.pow(b, toComplex(3.0))), math.subtract(toComplex(1.0), math.pow(b, toComplex(4.0))))));
}

function metallicRatio(b) {
    return math.divide(math.add(b, math.sqrt(math.add(math.pow(b, toComplex(2.0)), toComplex(4.0)))), toComplex(2.0));
}

function joukowsky(b) {
    return math.add(b, math.divide(toComplex(1.0), b));
}

function karmantrefftz(a, b) {
    const expPart = math.pow(math.add(b, a), math.subtract(toComplex(2.0), math.divide(globalc, math.pi)));
    const denom = math.subtract(expPart, math.pow(math.subtract(b, a), math.subtract(toComplex(2.0), math.divide(globalc, math.pi))));
    return math.divide(math.multiply(math.subtract(toComplex(2.0), math.divide(globalc, math.pi)), expPart), denom);
}

function symmetricalJoukowsky(b, a) {
    return math.multiply(math.exp(math.complex(0, globalc)), math.add(math.subtract(b, a), math.add(math.divide(toComplex(1.0), math.subtract(b, a)), math.divide(math.multiply(toComplex(2.0), math.pow(a, toComplex(2.0))), math.add(a, globalc)))));
}

function cayley(b) {
    return math.divide(math.subtract(b, math.complex(0.0, 1.0)), math.add(b, math.complex(1.0, 0.0)));
}

function bilinear(b) {
    return math.divide(math.subtract(b, toComplex(1.0)), math.add(b, toComplex(1.0)));
}

function poincareDiscMetric(a, b) {
    return math.multiply(toComplex(2.0), math.atanh(math.divide(math.subtract(a, b), math.subtract(toComplex(1.0), math.multiply(a, math.conj(b))))));
}

function poincareMetric(a, b) {
    return math.multiply(toComplex(2.0), math.atanh(math.divide(math.subtract(a, b), math.subtract(a, math.conj(b)))));
}

// Helper functions
function toComplex(value) {
    return math.complex(value);
}

function pow(base, exponent) {
    return math.pow(base, exponent);
}

function sigm(x) {
    return math.divide(1.0, math.add(1.0, math.exp(math.multiply(-1.0, x))));
}

// Main operations
function collatz(b) {
    return math.add(
        math.multiply(math.divide(b, toComplex(2.0)), pow(math.cos(math.multiply(math.pi, math.divide(b, toComplex(2.0)))), toComplex(2.0))),
        math.multiply(
            math.add(math.multiply(toComplex(3.0), b), toComplex(1.0)),
            pow(math.sin(math.multiply(math.pi, math.divide(b, toComplex(2.0)))), toComplex(2.0))
        )
    );
}

function zeromosaic(b, a) {
    const quotient = math.round(math.divide(b, a));
    return math.multiply(
        pow(math.subtract(b, math.multiply(a, quotient)), a),
        pow(math.divide(a, toComplex(2.0)), math.multiply(-a, quotient))
    );
}

function initialmass(b) {
    return math.multiply(
        math.divide(toComplex(79.0), math.multiply(math.multiply(toComplex(500.0), b), math.log(toComplex(10.0)))),
        pow(math.exp(math.multiply(-1.0, math.divide(
            math.multiply(toComplex(5000.0), pow(math.subtract(math.log(b), math.log(toComplex(2.0, 25.0))), toComplex(2.0))),
            math.multiply(math.multiply(toComplex(4761.0), math.log(toComplex(10.0))), math.log(toComplex(10.0)))
        ))), toComplex(1.0))
    );
}

function initialmass2(b) {
    return math.multiply(
        math.divide(toComplex(43.0), math.multiply(math.multiply(toComplex(500.0), b), math.log(toComplex(10.0)))),
        pow(math.exp(math.multiply(-1.0, math.divide(
            math.multiply(toComplex(5000.0), pow(math.subtract(math.log(b), math.log(toComplex(11.0, 50.0))), toComplex(2.0))),
            math.multiply(math.multiply(toComplex(3249.0), math.log(toComplex(10.0))), math.log(toComplex(10.0)))
        ))), toComplex(1.0))
    );
}

function kroupa(a, b) {
    return math.add(
        math.multiply(pow(a, math.multiply(toComplex(-23.0), math.divide(toComplex(1.0), toComplex(10.0)))), sigm(math.multiply(math.subtract(a, toComplex(0.5)), math.exp(b)))),
        math.multiply(
            toComplex(2.0),
            math.multiply(
                pow(a, math.multiply(toComplex(-13.0), math.divide(toComplex(1.0), toComplex(10.0)))),
                sigm(math.multiply(math.subtract(a, toComplex(0.5)), math.exp(b)))
            )
        )
    );
}

function kroupatoutgilmore(a, b) {
    return math.add(
        math.multiply(
            pow(a, math.multiply(toComplex(-27.0), math.divide(toComplex(1.0), toComplex(10.0)))),
            sigm(math.multiply(math.subtract(a, toComplex(1.0)), math.exp(b)))
        ),
        math.multiply(
            math.multiply(toComplex(19.0), math.divide(toComplex(1.0), toComplex(1000.0))),
            math.multiply(
                pow(a, math.multiply(toComplex(-11.0), math.divide(toComplex(1.0), toComplex(5.0)))),
                sigm(math.multiply(math.subtract(a, toComplex(1.0)), math.exp(b)))
            )
        )
    );
}

function larsona(b) {
    return math.multiply(pow(b, math.multiply(toComplex(-47.0), math.divide(toComplex(1.0), toComplex(20.0)))), math.exp(math.divide(toComplex(1.0), b)));
}

function larsonb(b) {
    return math.multiply(
        math.multiply(
            pow(toComplex(2.0), math.multiply(toComplex(27.0), math.divide(toComplex(1.0), toComplex(20.0)))),
            pow(math.add(b, toComplex(1.0)), math.multiply(toComplex(-27.0), math.divide(toComplex(1.0), toComplex(20.0))))
        ),
        math.divide(toComplex(1.0), b)
    );
}

function salpeter(b) {
    return pow(b, math.multiply(toComplex(-47.0), math.divide(toComplex(1.0), toComplex(20.0))));
}

function sigmoid(b) {
    return sigm(b);
}

function generalizedlogistic(b, a) {
    return pow(math.add(toComplex(1.0), math.exp(math.multiply(toComplex(-1.0), b))), math.multiply(-a, toComplex(1.0)));
}

function logisticphi(b, a) {
    return math.equal(b, toComplex(0.0))
        ? math.exp(math.multiply(-a, toComplex(1.0)))
        : pow(math.subtract(toComplex(1.0), math.multiply(b, a)), math.divide(toComplex(1.0), b));
}

function logisticregression(b) {
    return math.divide(toComplex(1.0), math.add(toComplex(1.0), math.exp(math.multiply(toComplex(-1.0), b))));
}

function softplus(b) {
    return math.log(math.add(toComplex(1.0), math.exp(b)));
}

function sobolevatanh(b) {
    return math.add(math.tanh(b), math.multiply(b, math.multiply(
        math.divide(toComplex(1.0), math.cosh(b)),
        math.divide(toComplex(1.0), math.cosh(b))
    )));
}

function swish(b) {
    return math.divide(b, math.add(toComplex(1.0), math.exp(math.multiply(toComplex(-1.0), b))));
}

function fermidirac(b) {
    return math.divide(toComplex(1.0), math.add(math.exp(b), toComplex(1.0)));
}

function boseeinstein(b, a) {
    return math.divide(pow(b, a), math.subtract(math.exp(math.subtract(b, globalc)), toComplex(1.0)));
}

function einstein1(b) {
    return math.divide(math.multiply(b, b, math.exp(b)), pow(math.subtract(math.exp(b), toComplex(1.0)), toComplex(2.0)));
}

function einstein2(b) {
    return math.divide(b, math.subtract(math.exp(b), toComplex(1.0)));
}

function einstein3(b) {
    return math.log(math.subtract(toComplex(1.0), math.exp(math.multiply(toComplex(-1.0), b))));
}

function einstein4(b) {
    return math.subtract(
        math.divide(b, math.subtract(math.exp(b), toComplex(1.0))),
        math.log(math.subtract(toComplex(1.0), math.exp(math.multiply(toComplex(-1.0), b))))
    );
}

function probit(a, b) {
    return math.multiply(
        math.sqrt(toComplex(2.0)),
        math.multiply(
            a,
            math.add(
                math.multiply(math.sqrt(math.pi), math.divide(b, toComplex(2.0))),
                math.multiply(
                    math.divide(math.multiply(b, b, b, math.pi), toComplex(12.0)),
                    math.add(
                        math.divide(
                            math.multiply(pow(math.subtract(toComplex(2.0), b), toComplex(5.0)), toComplex(7.0)), 
                            math.multiply(math.pi, toComplex(480.0))
                        ),
                        math.divide(
                            math.multiply(pow(math.subtract(toComplex(2.0), b), toComplex(7.0)), toComplex(127.0)),
                            math.multiply(math.pi, math.multiply(toComplex(40320.0), math.pi))
                        )
                    )
                )
            )
        )
    );
}

function logitlogistic(a, b) {
    return math.divide(a, math.add(toComplex(1.0), math.exp(math.multiply(toComplex(-1.0), b))));
}

function cloglog(b) {
    return math.multiply(-1.0, math.log(math.multiply(-1.0, math.log(math.subtract(toComplex(1.0), math.exp(math.multiply(toComplex(-1.0), b)))))));
}

function gompertz(a, b) {
    return math.exp(math.multiply(-1.0, math.exp(math.multiply(-a, math.subtract(b, toComplex(1.0))))));
}

function log_logistic(a, b) {
    return math.divide(toComplex(1.0), math.add(toComplex(1.0), pow(math.divide(b, a), toComplex(-1.0))));
}

function logistic_exponential(a, b) {
    return math.divide(math.multiply(a, math.exp(b)), math.add(toComplex(1.0), math.exp(b)));
}

function log_odds(b) {
    return math.log(math.divide(b, math.subtract(toComplex(1.0), b)));
}

function pi() {
    return toComplex(math.pi);
}

// Main functions
function rastrigin(a, b) {
    const ten = toComplex(10.0);
    const twoPi = math.multiply(toComplex(2.0), pi());
    return math.add(
        math.multiply(ten, toComplex(2.0)),
        math.add(
            math.subtract(math.multiply(a, a), math.multiply(ten, math.cos(math.multiply(twoPi, a)))),
            math.subtract(math.multiply(b, b), math.multiply(ten, math.cos(math.multiply(twoPi, b))))
        )
    );
}

function ackley(a, b) {
    const negTwenty = toComplex(-20.0);
    const e = math.e;
    const half = toComplex(0.5);
    const expTerm = math.exp(math.multiply(negTwenty, math.sqrt(math.multiply(half, math.add(math.multiply(a, a), math.multiply(b, b))))));
    const cosTerm = math.exp(math.multiply(0.5, math.add(math.cos(math.multiply(toComplex(2.0), pi(), a)), math.cos(math.multiply(toComplex(2.0), pi(), b)))));
    return math.add(
        math.subtract(expTerm, cosTerm),
        math.add(e, toComplex(20.0))
    );
}

function sphere(a, b) {
    return math.add(math.multiply(a, a), math.multiply(b, b));
}

function rosenbrock(a, b) {
    const hundred = toComplex(100.0);
    return math.add(
        math.multiply(hundred, math.pow(math.subtract(b, math.multiply(a, a)), 2)),
        math.pow(math.subtract(toComplex(1.0), a), 2)
    );
}

function beale(a, b) {
    return math.add(
        math.pow(math.subtract(math.add(toComplex(1.5), math.multiply(math.subtract(a, math.multiply(a, b)), b)), math.multiply(a, b)), 2),
        math.add(
            math.pow(math.subtract(math.add(toComplex(2.25), math.multiply(math.subtract(a, math.multiply(a, b)), math.multiply(b, b))), math.multiply(a, math.multiply(b, b))), 2),
            math.pow(math.subtract(math.add(toComplex(2.625), math.multiply(math.subtract(a, math.multiply(a, b)), math.multiply(b, b, b))), math.multiply(a, math.multiply(b, b, b))), 2)
        )
    );
}

function goldsteinprice(a, b) {
    const one = toComplex(1.0);
    const thirty = toComplex(30.0);
    const nineteen = toComplex(19.0);
    const fourteen = toComplex(14.0);
    const three = toComplex(3.0);
    const eighteen = toComplex(18.0);
    const thirtyTwo = toComplex(32.0);
    const twelve = toComplex(12.0);
    const fortyEight = toComplex(48.0);
    const thirtySix = toComplex(36.0);
    const twentySeven = toComplex(27.0);

    const term1 = math.add(
        one,
        math.multiply(math.pow(math.add(a, b, one), 2), math.add(
            nineteen,
            math.subtract(math.multiply(fourteen, a), math.multiply(three, math.pow(a, 2))),
            math.subtract(math.multiply(fourteen, b), math.multiply(math.multiply(six, a), b)),
            math.multiply(three, math.pow(b, 2))
        ))
    );
    const term2 = math.add(
        thirty,
        math.multiply(math.pow(math.subtract(math.multiply(two, a), math.multiply(three, b)), 2), math.add(
            eighteen,
            math.subtract(math.multiply(thirtyTwo, a), math.multiply(twelve, math.pow(a, 2))),
            math.add(
                fortyEight,
                math.subtract(math.multiply(thirtySix, a), math.multiply(math.multiply(three, a), b)),
                math.multiply(twentySeven, math.pow(b, 2))
            )
        ))
    );

    return math.multiply(term1, term2);
}

function booth(a, b) {
    return math.add(
        math.pow(math.subtract(math.add(a, math.multiply(two, b)), toComplex(7.0)), 2),
        math.pow(math.subtract(math.add(math.multiply(two, a), b), toComplex(5.0)), 2)
    );
}

function bukin(a, b) {
    const hundred = toComplex(100.0);
    const point01 = toComplex(0.01);
    return math.add(
        math.multiply(hundred, math.sqrt(math.abs(math.subtract(b, math.multiply(point01, math.pow(a, 2)))))),
        math.multiply(point01, math.abs(math.add(a, toComplex(10.0))))
    );
}

function matyas(a, b) {
    return math.subtract(
        math.multiply(toComplex(0.26), math.add(math.multiply(a, a), math.multiply(b, b))),
        math.multiply(toComplex(0.48), math.multiply(a, b))
    );
}

function levi(a, b) {
    const threePi = math.multiply(toComplex(3.0), pi());
    const twoPi = math.multiply(toComplex(2.0), pi());
    return math.add(
        math.pow(math.sin(threePi, a), 3),
        math.multiply(math.pow(math.subtract(a, toComplex(1.0)), 2), math.add(toComplex(1.0), math.pow(math.sin(threePi, b), 3))),
        math.multiply(math.pow(math.subtract(b, toComplex(1.0)), 2), math.add(toComplex(1.0), math.pow(math.sin(twoPi, b), 2)))
    );
}

function himmelblau(a, b) {
    return math.add(
        math.pow(math.subtract(math.multiply(a, a), toComplex(11.0)), 2),
        math.pow(math.subtract(math.multiply(a, math.multiply(b, b)), toComplex(7.0)), 2)
    );
}

function threehump(a, b) {
    return math.add(
        math.multiply(toComplex(2.0), math.pow(a, 2)),
        math.subtract(
            math.multiply(toComplex(1.05), math.pow(a, 4)),
            math.divide(math.multiply(a, math.pow(a, 4)), toComplex(6.0))
        ),
        math.add(
            math.multiply(a, b),
            math.multiply(b, b)
        )
    );
}

function easom(a, b) {
    return math.multiply(
        math.multiply(math.cos(a), math.cos(b)),
        math.exp(math.subtract(
            math.multiply(
                toComplex(-1.0),
                math.add(
                    math.pow(math.subtract(a, pi()), 2),
                    math.pow(math.subtract(b, pi()), 2)
                )
            )
        ))
    );
}

function crossintray(a, b) {
    return math.pow(
        math.subtract(
            toComplex(-0.0001),
            math.multiply(
                math.sin(a),
                math.sin(b),
                math.exp(
                    math.abs(
                        math.subtract(
                            toComplex(100.0),
                            math.divide(math.sqrt(math.add(math.pow(a, 2), math.pow(b, 2))), pi())
                        )
                    )
                )
            )
        ),
        toComplex(0.1)
    );
}
function eggholder(a, b) {
    const fortySeven = toComplex(47.0);
    return math.multiply(
        toComplex(-1.0),
        math.add(
            math.multiply(math.add(b, fortySeven), math.sin(math.sqrt(math.abs(math.add(math.divide(a, toComplex(2.0)), fortySeven))))),
            math.multiply(math.sin(math.sqrt(math.abs(math.subtract(a, math.add(b, fortySeven))))), toComplex(-1.0))
        )
    );
}

function holdertable(a, b) {
    return math.multiply(
        toComplex(-1.0),
        math.abs(
            math.multiply(math.sin(a), math.cos(b)),
            math.exp(math.abs(math.subtract(toComplex(1.0), math.divide(math.sqrt(math.add(math.pow(a, 2), math.pow(b, 2))), pi()))))
        )
    );
}

function mccormick(a, b) {
    return math.add(
        math.sin(math.add(a, b)),
        math.add(
            math.pow(math.subtract(a, b), 2),
            math.add(
                math.multiply(toComplex(-1.5), a),
                math.add(
                    math.multiply(toComplex(2.5), b),
                    toComplex(1.0)
                )
            )
        )
    );
}

function schaffern2(a, b) {
    const denom = math.pow(math.add(toComplex(1.0), math.multiply(toComplex(0.001), math.add(math.pow(a, 2), math.pow(b, 2)))), 2);
    return math.divide(
        math.subtract(math.pow(math.sin(math.subtract(math.pow(a, 2), math.pow(b, 2))), 2), toComplex(0.5)),
        denom
    );
}

function schaffern4(a, b) {
    const denom = math.pow(math.add(toComplex(1.0), math.multiply(toComplex(0.001), math.add(math.pow(a, 2), math.pow(b, 2)))), 2);
    return math.divide(
        math.subtract(math.pow(math.cos(math.sin(math.abs(math.subtract(math.pow(a, 2), math.pow(b, 2))))), 2), toComplex(0.5)),
        denom
    );
}

function styblinskitang(a, b) {
    const sixteen = toComplex(16.0);
    const five = toComplex(5.0);
    return math.divide(
        math.add(
            math.add(
                math.subtract(math.pow(a, 4), math.multiply(sixteen, a)),
                math.add(five, a)
            ),
            math.add(
                math.subtract(math.pow(b, 4), math.multiply(sixteen, b)),
                math.add(five, b)
            )
        ),
        toComplex(2.0)
    );
}

function mihrasbird(a, b) {
    return math.add(
        math.multiply(math.sin(b), math.exp(math.pow(math.subtract(toComplex(1.0), math.cos(a)), 2))),
        math.add(
            math.multiply(math.sin(a), math.exp(math.pow(math.subtract(toComplex(1.0), math.cos(b)), 2))),
            math.pow(math.subtract(a, b), 2)
        )
    );
}

function townsend(a, b) {
    return math.subtract(
        toComplex(-1.0),
        math.add(
            math.pow(math.cos(math.multiply(math.subtract(a, toComplex(0.1)), b)), 2),
            math.multiply(a, math.sin(math.add(math.multiply(toComplex(3.0), a), b)))
        )
    );
}

function gomezlevi(a, b) {
    const four = toComplex(4.0);
    const twoPointOne = toComplex(2.1);
    const six = toComplex(6.0);
    return math.add(
        math.add(
            math.multiply(four, math.pow(a, 2)),
            math.subtract(
                math.multiply(twoPointOne, math.pow(a, 4)),
                math.divide(math.pow(a, 5), six)
            )
        ),
        math.add(
            math.multiply(a, b),
            math.subtract(
                math.multiply(four, math.pow(b, 2)),
                math.multiply(four, math.pow(b, 4))
            )
        )
    );
}

function simionescu(a, b) {
    return math.multiply(toComplex(0.1), math.multiply(a, b));
}

function griewank(a, b) {
    const sum = math.add(math.pow(a, 2), math.pow(b, 2));
    return math.add(
        toComplex(1.0),
        math.subtract(
            math.divide(sum, toComplex(4000.0)),
            math.multiply(math.cos(a), math.cos(math.divide(b, math.sqrt(toComplex(2.0)))))
        )
    );
}

function schwefel221(a, b) {
    return math.multiply(toComplex(0.01), math.add(math.abs(a), math.abs(b)));
}

function schwefel222(a, b) {
    return math.max(math.abs(a), math.abs(b));
}

function bird(a, b) {
    return math.add(
        math.multiply(math.sin(a), math.exp(math.pow(math.subtract(toComplex(1.0), math.cos(b)), 2))),
        math.add(
            math.multiply(math.cos(b), math.exp(math.pow(math.subtract(toComplex(1.0), math.sin(a)), 2))),
            math.pow(math.subtract(a, b), 2)
        )
    );
}

function alpine(a, b) {
    return math.add(
        math.abs(math.add(math.multiply(a, math.sin(a)), math.multiply(toComplex(0.1), a))),
        math.abs(math.add(math.multiply(b, math.sin(b)), math.multiply(toComplex(0.1), b)))
    );
}

function sdp(a, b) {
    return math.add(
        math.pow(math.abs(a), 2),
        math.pow(math.abs(b), 3)
    );
}

function sumsquaresonsphere(a, b) {
    return math.add(
        math.add(
            math.pow(a, 2),
            math.pow(b, 2)
        ),
        math.subtract(
            math.subtract(
                math.cos(math.multiply(toComplex(18.0), a, pi())),
                math.cos(math.multiply(toComplex(18.0), b, pi()))
            )
        )
    );
}

function michalewicz(a, b) {
    const m = math.round(a); // rounding a to nearest integer for use in the loop
    let sum = toComplex(0.0);
    for (let i = 1; i <= m; i++) {
        sum = math.add(sum, math.multiply(
            math.sin(b),
            math.pow(math.sin(math.multiply(i, b, b, math.divide(math.pi, m))), math.multiply(2, m))
        ));
    }
    return math.multiply(toComplex(-1.0), sum);
}

function booths(a, b) {
    return math.add(
        math.pow(math.add(a, math.multiply(toComplex(2.0), b), toComplex(-7.0)), 2),
        math.pow(math.add(math.multiply(toComplex(2.0), a), b, toComplex(-5.0)), 2)
    );
}

function sumsquares(a, b) {
    return math.add(
        math.pow(a, 2),
        math.pow(b, 2)
    );
}

function bohachevsky(a, b) {
    return math.add(
        math.add(
            math.pow(a, 2),
            math.multiply(toComplex(2.0), math.pow(b, 2))
        ),
        math.add(
            math.multiply(toComplex(-0.3), math.cos(math.multiply(toComplex(3.0), pi(), a))),
            math.add(
                math.multiply(toComplex(-0.4), math.cos(math.multiply(toComplex(4.0), pi(), b))),
                toComplex(0.7)
            )
        )
    );
}

function sixhumpcamel(a, b) {
    return math.add(
        math.multiply(
            math.add(
                toComplex(4.0),
                math.subtract(math.multiply(toComplex(-2.1), math.pow(a, 2)), math.divide(math.pow(a, 4), toComplex(3.0)))
            ),
            math.pow(a, 2)
        ),
        math.add(
            math.multiply(a, b),
            math.multiply(
                math.subtract(
                    toComplex(-4.0),
                    math.multiply(toComplex(4.0), math.pow(b, 2))
                ),
                math.pow(b, 2)
            )
        )
    );
}

function shubert(a, b) {
    let sum1 = toComplex(0.0);
    let sum2 = toComplex(0.0);
    for (let i = 1; i <= 5; i++) {
        sum1 = math.add(
            sum1,
            math.multiply(i, math.cos(math.add(math.multiply(math.add(i, toComplex(1.0)), a), i)))
        );
        sum2 = math.add(
            sum2,
            math.multiply(i, math.cos(math.add(math.multiply(math.add(i, toComplex(1.0)), b), i)))
        );
    }
    return math.multiply(sum1, sum2);
}

function acosc(b) {
    const const1 = toComplex(2.798386045783887);
    const const2 = toComplex(0.33650841691839534);
    const const3 = toComplex(-0.33650841691839534);
    const const4 = toComplex(3.0 * 2.798386045783887 * -0.33650841691839534);

    let fi = math.subtract(
        const1,
        math.pow(math.divide(math.multiply(toComplex(2.0), math.add(b, const2)), const2), toComplex(0.5))
    );

    fi = math.subtract(
        fi,
        math.divide(math.multiply(toComplex(2.0), math.add(b, const2)), const4)
    );

    for (let i = 0; i < 5; i++) {
        const fiDenom = math.divide(
            math.subtract(math.cos(fi), fi),
            math.multiply(math.divide(math.subtract(math.sin(fi), math.cos(fi)), fi), fi)
        );

        fi = math.add(fi, math.divide(
            math.subtract(b, math.divide(math.cos(fi), fi)),
            fiDenom
        ));
    }

    return fi;
}

function acosq(b) {
    return acosc(math.multiply(
        toComplex(0, 1),
        math.divide(pi(), toComplex(4.0))
    ) * toComplex(b));
}

function asinc(b) {
    const bs = math.subtract(toComplex(1.0), b);
    let fi = math.divide(
        math.multiply(math.sqrt(math.multiply(toComplex(6.0), bs)), math.sin(bs)),
        bs
    );

    for (let i = 0; i < 5; i++) {
        const fiDenom = math.divide(
            math.subtract(math.cos(fi), math.sin(fi)),
            math.multiply(math.divide(math.subtract(math.sin(fi), math.cos(fi)), fi), fi)
        );

        fi = math.add(fi, math.divide(
            math.subtract(b, math.divide(math.sin(fi), fi)),
            fiDenom
        ));
    }

    return fi;
}

function dedekindeta(z) {
 
    const eulerConstant = eulerc();
    const exponent = math.multiply(toComplex(2.0), z, pi(), math.complex(0,1));
    const q = math.pow(eulerConstant, exponent);
    let p = math.pow(q, math.divide(toComplex(1.0), toComplex(24.0)));
    


    for (let id = 1; id < 20; id++) {
        const qi = math.pow(q, toComplex(id));
        p = math.multiply(p, math.subtract(toComplex(1.0), qi));
    }

    return p;
}

function einsteinseries(a, b) {
    let fi = toComplex(0);
    const limit = toComplex(5);
    
    for (let i = -limit; i < limit; i++) {
        for (let j = -limit; j < limit; j++) {
            if (i !== 0 || j !== 0) {
                const denominator = pow(math.add(i,math.multiply(j ,b)), a);
                if (denominator !== 0) {
                    fi = math.add(fi, math.divide(toComplex(1), denominator));
                }
            }
        }
    }
    
    return fi;
}

// Fourier Einstein function
function fouriereinstein(a, b) {
    return math.multiply(einsteinseries(a, b), toComplex(2.0), ZZZ(a));
}



// Define ZZZ function based on your actual implementation
function ZZZ(x) {
        return math.multiply(math.divide(toComplex(1.0), math.subtract(toComplex(1.0), math.pow(toComplex(2.0), math.subtract(toComplex(1.0), x)))),dirichleteta(x));
}

function laurentexpansion(a,c,z) {
    let fi = toComplex(0);
    for (let i = 1; i < 30; i++) {
        fi =  math.add(pow(math.multiply(math.subtract(z,c),a),toComplex(i)), fi);
    }
return fi;
}

// Dirichlet Character function
function dirichletchar(a, b) {
    return (abs(gcd(a, b)) === 1) ? toComplex(1.0) : toComplex(0.0);
}
function ncr(n, r) 
{ 
    return facti(n) / (facti(r) * facti(n - r)); 
} 

// Returns factorial of n 
function facti(n) 
{ 
      if(n==0 || n==1)
      return 1;
    var res = 1; 
    for (var i = 2; i <= n; i++) 
        res = res * i; 
    return res; 
} 
// Dirichlet Eta function
function dirichleteta(b) {
    let t = toComplex(0);
    let fi = toComplex(0);
    
    for (let i = 0; i < 15; i++) {
        t = toComplex(0);
        for (let j = 0; j <= i; j++) {
            t = math.add(t, math.multiply(ncr(i, j), math.divide(pow(-1.0, j), pow(j + 1.0, b))));
        }
        fi = math.add(fi, math.divide(t, pow(2.0, i + 1.0)));
    }
    
    return fi;
}

function dirichletbeta(b) {
    b = toComplex(b); // Ensure b is complex
    let fi = toComplex(0);
    let mul = toComplex(1);

    if (b.re <= 0.5) {
        // Calculate multiplication factor
        const piHalf = math.divide(pi(), toComplex(2));
        const bMinus1 = math.subtract( toComplex(1),b);
        mul = math.multiply(
            math.pow(piHalf, math.subtract(toComplex(0),bMinus1)),
            math.sin(math.divide(math.multiply(pi(), bMinus1), toComplex(2))),
            gamma(bMinus1),dirichletbeta(bMinus1)
        );


return mul;
    }

    // Summation part
    for (let n = 0; n < bign; n++) {
        fi = math.add(
            fi,
            math.divide(
                math.pow(-1, n),
                math.pow(math.add(2 * n, 1), b)
            )
        );
    }
    
    return fi;
}



function gammad(t, z) {
    return math.multiply(pow(t, math.subtract(z,toComplex(1)) ),math.exp(-t));
}
function gamma(z) {
    // Convert z to a complex number if it's not already
    const complexZ = math.complex(z);

    // Initialize the function with exp(-0.577216 * z) / z
    let fi = math.divide(math.exp(math.multiply(-0.577216, complexZ)), complexZ);

    // Loop to compute the product
    for (let i = 1; i < 20; i++) {
        let term = math.divide(complexZ, i);
        fi = math.multiply(fi, math.divide(math.exp(term), math.add(1, term)));
    }

    return fi;
}

function jacobiTheta1(z, q) {
    let fi = math.complex(0, 0);
    
    for (let n = 0; n < bign; n++) {
        let term = math.multiply(
            math.pow(-1, n),
            math.pow(q, math.pow(n + 0.5, 2)),
            math.sin(math.multiply(2 * n + 1, z))
        );
        fi = math.add(fi, term);
    }
    
    return math.multiply(fi, 2.0);
}

// Define the jacobiTheta2 function
function jacobiTheta2(z, q) {
    let fi = math.complex(0, 0);
    
    for (let n = 0; n < bign; n++) {
        let term = math.multiply(
            math.pow(q, math.pow(n + 0.5, 2)),
            math.cos(math.multiply(2 * n + 1, z))
        );
        fi = math.add(fi, term);
    }
    
    return math.multiply(fi, 2.0);
}

// Define the jacobiTheta3 function
function jacobiTheta3(z, q) {
    let fi = math.complex(1, 0);
    
    for (let n = 1; n < bign; n++) {
        let term = math.multiply(
            math.pow(q, n * n),
            math.cos(math.multiply(2 * n, z))
        );
        fi = math.add(fi, term);
    }
    
    return math.multiply(fi, 2.0);
}

// Define the jacobiTheta4 function
function jacobiTheta4(z, q) {
    let fi = math.complex(1, 0);
    
    for (let n = 1; n < bign; n++) {
        let term = math.multiply(
            math.pow(-1, n),
            math.pow(q, n * n),
            math.cos(math.multiply(2 * n, z))
        );
        fi = math.add(fi, term);
    }
    
    return math.multiply(fi, 2.0);
}

function jinvariant(z) {
    // Calculate a1 and a2
    const a1 = math.pow(dedekindeta(z), 24.0);
    const a2 = math.pow(dedekindeta(math.multiply(2.0, z)), 24.0);
    
    // Compute the final result
    const numerator = math.pow(math.add(a1, math.multiply(256.0, a2)), 3.0);
    const denominator = math.multiply(1728.0, math.pow(a1, 2.0), a2);
    
    return math.divide(numerator, denominator);
}
function lemniscaten(b) {
    return math.divide(
        lemniscatem(math.multiply(math.complex(1.0, 1.0), b)),
        math.multiply(math.complex(1.0, 1.0), lemniscatem( b))
    );
}

function lemniscatem(b) {
    let fi = toComplex(b);
    for (let i = 1; i < 5; i++) {
        for (let j = 0; j < 5; j++) {
            const l = math.complex(math.multiply(2.62205755 , i), math.multiply(2.62205755 , j));
            const term = math.divide(math.pow(b, 4), math.pow(l, 4));
            fi = math.multiply(fi, math.subtract(toComplex(1.0), term));
        }
    }
    return fi;
}


function lemniscates(b) {
    return math.subtract(
        math.pow(lemniscaten(math.divide(b, math.complex(1.0, 1.0))), toComplex(2)),
        math.multiply(math.complex(0, 1), math.pow(lemniscatem( math.divide(b, math.complex(1.0, 1.0))), toComplex(2)))
    );
}

function lemniscatet(a) {
let b = math.multiply(a,math.complex(0,1));
    return lemniscates(b);
}



function sl(a) {
let b = math.subtract(1.311028775 , a);
    const l1 = lemniscates(b);
    const l2 = lemniscatet(b);
    return math.divide(l1, l2);
}

function cl(x) {
    const l1 = lemniscates(x);
    const l2 = lemniscatet(x);
    return math.divide(l1, l2);
}

function lemniscatetan(b) {
    return math.divide(
        sl(b),
        cl(b)
    );
}

function lemniscatecot(b) {
    return math.divide(
        cl(b),
        sl(b)
    );
}

function lemniscatecsc(b) {
  return math.divide(toComplex(1),sl(s));
}

function lemniscatesec(b) {
 return math.divide(toComplex(1),cl(s));
}

function tlh(b) {
    const fisl = sl(math.divide(b, math.sqrt(2.0)));
    const ficl = cl(math.divide(b, math.sqrt(2.0)));
    return math.multiply(fisl, math.sqrt(math.divide(math.add(math.pow(ficl, 2), toComplex(1.0)), math.add(math.pow(fisl, 2), math.multiply(ficl, ficl)))));
}

function ctlh(b) {
    const fisl = sl(math.divide(b, math.sqrt(2.0)));
    const ficl = cl(math.divide(b, math.sqrt(2.0)));
    return math.multiply(ficl, math.sqrt(math.divide(math.add(math.pow(fisl, 2), toComplex(1.0)), math.add(math.pow(fisl, 2), math.multiply(ficl, ficl)))));

   }

function polygonal(a, b) {
    return math.divide(
        math.subtract(
            math.multiply(math.subtract(a, toComplex(2.0)), math.pow(b, 2)),
            math.multiply(math.subtract(a, toComplex(4.0)), b)
        ),
        toComplex(2.0)
    );
}

function antisidepolygonal(a, b) {
    const term1 = math.multiply(toComplex(8.0), math.subtract(a, toComplex(2.0)));
    const term2 = math.subtract(math.pow(b, 2), math.multiply(toComplex(4.0), b));
    return math.divide(
        math.add(math.sqrt(math.add(term1, term2)), math.subtract(a, toComplex(4.0))),
        math.subtract(math.multiply(toComplex(2.0), a), toComplex(4.0))
    );
}

function antipolygonal(a, b) {
    return antisidepolygonal(a, b);
}

function centeredpolygonal(a, b) {
    return math.add(
        math.multiply(math.divide(a, toComplex(2.0)), math.multiply(b, math.subtract(b, toComplex(1.0)))),
        toComplex(1.0)
    );
}

function pyramidal(a, b) {
    return math.divide(
        math.add(
            math.multiply(toComplex(3.0), math.pow(b, 2)),
            math.add(
                math.multiply(math.pow(b, 2), math.subtract(a, toComplex(2.0))),
                math.subtract(math.multiply(toComplex(-1.0), b), math.subtract(a, toComplex(5.0)))
            )
        ),
        toComplex(6.0)
    );
}

function star(b) {
    return math.add(
        math.multiply(toComplex(6.0), math.multiply(b, math.subtract(b, toComplex(1.0)))),
        toComplex(1.0)
    );
}

function starprime(b) {
    let i = toComplex(0.0);
    while (math.larger(math.abs(i), math.abs(b))) {
        if (isPrime(math.add(math.multiply(toComplex(6.0), math.multiply(i, math.subtract(i, toComplex(1.0)))), toComplex(1.0)))) {
            i = math.add(i, toComplex(1.0));
        }
    }
    return i;
}

function superstarprime(b) {
    let i = toComplex(0.0);
    while (math.larger(math.abs(i), math.abs(b))) {
        if (isPrime(math.add(math.multiply(toComplex(6.0), math.multiply(nthPrime(i), math.subtract(nthPrime(i), toComplex(1.0)))), toComplex(1.0)))) {
            i = math.add(i, toComplex(1.0));
        }
    }
    return i;
}

function reversesuperstar(b) {
    return math.add(
        math.multiply(toComplex(6.0), math.multiply(nthPrime(b), math.subtract(nthPrime(b), toComplex(1.0)))),
        toComplex(1.0)
    );
}

function superballot(b) {
    return math.divide(
        math.multiply(toComplex(60.0), gamma(math.add(math.multiply(toComplex(2.0), b), toComplex(1.0)))),
        math.multiply(gamma(math.add(b, toComplex(1.0))), gamma(math.add(b, toComplex(4.0))))
    );
}

function hauyoctahedral(b) {
    return math.divide(
        math.multiply(
            math.subtract(math.multiply(toComplex(2.0), b), toComplex(1.0)),
            math.subtract(math.multiply(toComplex(2.0), math.pow(b, 2)), math.add(math.multiply(toComplex(-2.0), b), toComplex(3.0)))
        ),
        toComplex(3.0)
    );
}

function hauyrhombicdodecahedronal(b) {
    return math.multiply(
        math.subtract(math.multiply(toComplex(2.0), b), toComplex(1.0)),
        math.subtract(math.multiply(toComplex(8.0), math.pow(b, 2)), math.add(math.multiply(toComplex(-14.0), b), toComplex(7.0)))
    );
}

function hauysquarepyramid(b) {
    return math.divide(
        math.multiply(b, math.subtract(math.multiply(toComplex(4.0), math.pow(b, 2)), toComplex(1.0))),
        toComplex(3.0)
    );
}

function octahedral(b) {
    return math.divide(
        math.multiply(b, math.add(math.multiply(toComplex(2.0), math.pow(b, 2)), toComplex(1.0))),
        toComplex(3.0)
    );
}

function pronic(b) {
    return math.multiply(b, math.add(b, toComplex(1.0)));
}

function biquadratic(b) {
    return math.pow(b, 4);
}

function surfolide(b) {
    return math.pow(b, 5);
}

function secondsurfolide(b) {
    return math.pow(b, 7);
}

function thirdsurfolide(b) {
    return math.pow(b, 11);
}

function fourthsurfolide(b) {
    return math.pow(b, 13);
}

function fifthsurfolide(b) {
    return math.pow(b, 17);
}

function sixthsurfolide(b) {
    return math.pow(b, 19);
}

function seventhsurfolide(b) {
    return math.pow(b, 23);
}

function nthsurfolide(b, a) {
    return math.pow(b, nthPrime(a + 2.0));
}

function zenzicube(b) {
    return math.pow(b, 6);
}

function cubicube(b) {
    return math.pow(b, 9);
}

function zenzizenzizenzic(b) {
    return math.pow(b, 8);
}

function zenzizenzicube(b) {
    return math.pow(b, 12);
}

function zenzizenzizenzizenzic(b) {
    return math.pow(b, 16);
}

function zenzicubicube(b) {
    return math.pow(b, 18);
}

function zenzizenzizenzicube(b) {
    return math.pow(b, 24);
}

function nthzenzic(b, a) {
    return math.pow(b, math.pow(toComplex(2.0), a));
}

function rhombicdodecahedronal(b) {
    return math.multiply(
        math.subtract(math.multiply(toComplex(2.0), b), toComplex(1.0)),
        math.subtract(math.multiply(toComplex(2.0), math.pow(b, 2)), math.add(math.multiply(toComplex(-2.0), b), toComplex(1.0)))
    );
}

function truncoctahedral(b) {
    return math.add(
        math.subtract(math.multiply(toComplex(16.0), math.pow(b, 3)), math.multiply(toComplex(33.0), math.pow(b, 2))),
        math.add(math.multiply(toComplex(24.0), b), toComplex(-6.0))
    );
}

function trunctetrahedral(b) {
    return math.divide(
        math.multiply(b, math.subtract(math.multiply(toComplex(23.0), math.pow(b, 2)), math.add(math.multiply(toComplex(-27.0), b), toComplex(10.0)))),
        toComplex(6.0)
    );
}

function trigonal(b) {
    return math.divide(math.multiply(b, math.subtract(b, toComplex(1.0))), toComplex(2.0));
}

function pentagonal(b) {
    return math.divide(
        math.subtract(
            math.multiply(math.subtract(toComplex(5.0), toComplex(2.0)), math.pow(b, 2)),
            math.multiply(math.subtract(toComplex(5.0), toComplex(4.0)), b)
        ),
        toComplex(2.0)
    );
}

function hexagonal(b) {
    return math.divide(
        math.subtract(
            math.multiply(math.subtract(toComplex(6.0), toComplex(2.0)), math.pow(b, 2)),
            math.multiply(math.subtract(toComplex(6.0), toComplex(4.0)), b)
        ),
        toComplex(2.0)
    );
}

function septagonal(b) {
    return math.divide(
        math.subtract(
            math.multiply(math.subtract(toComplex(7.0), toComplex(2.0)), math.pow(b, 2)),
            math.multiply(math.subtract(toComplex(7.0), toComplex(4.0)), b)
        ),
        toComplex(2.0)
    );
}

function octagonal(b) {
    return math.divide(
        math.subtract(
            math.multiply(math.subtract(toComplex(8.0), toComplex(2.0)), math.pow(b, 2)),
            math.multiply(math.subtract(toComplex(8.0), toComplex(4.0)), b)
        ),
        toComplex(2.0)
    );
}

function nonagonal(b) {
    return math.divide(
        math.subtract(
            math.multiply(math.subtract(toComplex(9.0), toComplex(2.0)), math.pow(b, 2)),
            math.multiply(math.subtract(toComplex(9.0), toComplex(4.0)), b)
        ),
        toComplex(2.0)
    );
}

function decaagonal(b) {
    return math.divide(
        math.subtract(
            math.multiply(math.subtract(toComplex(12.0), toComplex(2.0)), math.pow(b, 2)),
            math.multiply(math.subtract(toComplex(10.0), toComplex(4.0)), b)
        ),
        toComplex(2.0)
    );
}

function dodecagonalgonal(b) {
    return math.divide(
        math.subtract(
            math.multiply(math.subtract(toComplex(12.0), toComplex(2.0)), math.pow(b, 2)),
            math.multiply(math.subtract(toComplex(12.0), toComplex(4.0)), b)
        ),
        toComplex(2.0)
    );
}

function icosagonal(b) {
    return math.divide(
        math.subtract(
            math.multiply(math.subtract(toComplex(20.0), toComplex(2.0)), math.pow(b, 2)),
            math.multiply(math.subtract(toComplex(20.0), toComplex(4.0)), b)
        ),
        toComplex(2.0)
    );
}

function myriagonal(b) {
    return math.divide(
        math.subtract(
            math.multiply(math.subtract(toComplex(10000.0), toComplex(2.0)), math.pow(b, 2)),
            math.multiply(math.subtract(toComplex(10000.0), toComplex(4.0)), b)
        ),
        toComplex(2.0)
    );
}

// Simplex and Higher Dimensional Functions
function tetrahedral(b) {
    return nCr(math.add(b, toComplex(2.0)), toComplex(3.0));
}

function pentachoric(b) {
    return nCr(math.add(b, toComplex(3.0)), toComplex(4.0));
}

function simplex(b, a) {
    return nCr(math.add(b, a, toComplex(-1.0)), a);
}

// Gnomon Function
function gnomon(b) {
    return math.add(math.multiply(toComplex(2.0), b), toComplex(1.0));
}

const PI = math.pi;

// Barnes-G Function
function barnesg(b) {
    const aggs = math.multiply(pow(2.0 * PI, math.divide(b, 2.0)),  math.exp(math.multiply(-1, math.divide(math.add(b, math.multiply(b, math.add(b, 0.5772156649))), 2.0))));
    let aggt = toComplex(1, 0);

    for (let k = 1; k < bign; k++) {
        aggt = math.multiply(aggt, math.multiply(pow(math.add(1.0 , math.divide(b,k)), k), math.exp(math.subtract(math.divide(math.pow(b, 2), math.multiply(2,k)), b))));
    }

    return math.multiply(aggs, aggt);
}

// K-function (Corrected)
function kfunc(b) {
    const aggs = math.multiply(pow(2.0 * PI, math.divide(b, 2.0)), math.exp(math.multiply(-1, math.divide(math.add(b, math.multiply(b, math.add(b, 0.5772156649))), 2.0))));
    let aggt = toComplex(1, 0);

    for (let k = 1; k < bign; k++) {
        aggt = math.multiply(aggt, math.multiply(pow(math.add(1.0 , math.divide(b,k)), k), math.exp(math.subtract(math.divide(math.pow(b, 2),math.multiply(2,k)), b))));
    }

    return math.divide(math.pow(gamma(b), math.subtract(b, 1.0)), math.multiply(aggs, aggt));
}

// Beta Function
function beta(a, b) {
    return math.divide(math.multiply(gamma(a), gamma(b)), gamma(a + b));
}

// Pi number Functiondigamma(x)
function pin(b) {
    return math.divide(math.pow(gamma(math.divide(1, b)), toComplex(2)), gamma(math.add(math.divide(1, b), math.divide(1, b))));
}

// Digamma Function (Approximation)
function digamma(b, epsilon=1e-5) {
    const m1 = math.log(gamma(b));
    const m2 = math.log(gamma(math.add(b , epsilon)));
    return math.multiply(math.divide(math.subtract(m2, m1), epsilon), 1.0);
}

// Trigamma Function (Approximation)
function trigamma(b, epsilon=1e-5) {
    const m1 = math.log(gamma(b));
    const m2 = math.log(gamma(math.add(b , epsilon)));
    const m3 = math.log(gamma(math.add(math.add(b , epsilon) , epsilon)));
    return math.divide(math.subtract(math.subtract(m2, m1), math.subtract(m3, m2)), epsilon*epsilon);
}
function ellipticModulus(a, b) {
    return pow(math.divide(jacobiTheta2(a, b) , jacobiTheta1(a, b)), toComplex(2));
}

function compEllipticModulus(a, b) {
    return pow(math.divide(jacobiTheta4(a, b) , jacobiTheta1(a, b)), toComplex(2));
}

function ellipticLambda(a, b) {
    return pow(math.divide(jacobiTheta2(a, b) , jacobiTheta3(a, b)), toComplex(4));
}

function g2(b) {
    return math.multiply(60.0, einsteinseries(toComplex(4), b));
}

function g3(b) {
    return math.multiply(140.0, einsteinseries(toComplex(6), b));
}

function picardFuchsJ(b) {
    const g2Val = g2(b);
    const g3Val = g3(b);
    return math.divide(pow(g2Val, toComplex(3)), (pow(g2Val, toComplex(3)) - math.multiply(27.0, pow(g3Val, toComplex(2)))));
}

function ellipticDiscriminant(b) {
    const g2Val = g2(b);
    const g3Val = g3(b);
    return math.subtract(pow(g2Val, toComplex(3)), math.multiply(27.0, pow(g3Val, toComplex(2))));
}

function ellipticLambdaStar(a, b) {
    return pow(math.divide(jacobiTheta2(a, b), jacobiTheta3(a, b )), toComplex(2));
}
function ci(b) {
    return math.multiply(-1.0, integral(cosc, b, bign));
}

function nielsenci(a, b) {
    return math.multiply(-a, integral(cosc, b, bign));
}

function si(b) {
    return math.multiply(-1.0, integral(sinc, 0, b));
}

function nielsensi(a, b) {
    return math.multiply(-a, integral(sinc, 0, b));
}

function triintgauxf(b) {
    const integral_cosc = integral(cosc, b, bign);
    const integral_sinc = integral(sinc, 0, b);
    return math.add(
        math.multiply(
            math.multiply(-1.0, integral_cosc),
            math.sin(b)
        ),
        math.multiply(
            math.subtract(
                math.divide(math.PI, 2.0),
                math.multiply(-1.0, integral_sinc)
            ),
            math.cos(b)
        )
    );
}

function triintgauxg(b) {
    const integral_cosc = integral(cosc, b, bign);
    const integral_sinc = integral(sinc, 0, b);
    return math.add(
        math.multiply(
            math.multiply(-1.0, integral_cosc),
            math.cos(b)
        ),
        math.multiply(
            math.subtract(
                math.divide(math.PI, 2.0),
                math.multiply(-1.0, integral_sinc)
            ),
            math.sin(b)
        )
    );
}

// Function for "ein"
function ein(b) {
    return integral(expein, 0, b);
}
function ssi(b) {
    return math.multiply(-1.0, integral(sinhc, 0, b));
}

function shi(b) {
    return math.multiply(-1.0, integral(sind, 0, b));
}
function rec(b){return math.divide(toComplex(1),b);}
function chi(b) {
    return math.add(
        0.5772156649,
        math.subtract(
            math.multiply(log(b), integral(coshc, 0, b)),
            integral(rec, 0, b)
        )
    );
}


function ei(b) {
    return integral(expc, -bign, b);
}
function fresnelc(b) {
    return integral(cossqr, 0, b);
}

function fresnels(b) {
    return integral(sinsqr, 0, b);
}

function fresnelt(b) {
    const sinsqrIntegral = integral(sinsqr, 0, b);
    const cossqrIntegral = integral(cossqr, 0, b);
    return math.divide(sinsqrIntegral, cossqrIntegral);
}

function fresnelct(b) {
    const cossqrIntegral = integral(cossqr, 0, b);
    const sinsqrIntegral = integral(sinsqr, 0, b);
    return math.divide(cossqrIntegral, sinsqrIntegral);
}

function fresnelsc(b) {
    return math.divide(1.0, integral(cossqr, 0, b));
}

function fresnelcs(b) {
    return math.divide(1.0, integral(sinsqr, 0, b));
}

function gudermannian(b) {
    return integral(sech, 0, b);
}

function gudermanniani(b) {
    return integral(cosh_inv, 0, b);
}
let gcei1d = 0;
function compellint1d(a) {
return math.divide(1.0,math.sqrt(math.multiply(math.subtract(1.0,math.multiply(a,a)),math.subtract(1.0,math.multiply(math.multiply(a,a),math.multiply(gcei1d,gcei1d)))))) ;
}
function compellint1(a) {
gcei1d=a;
 return integral(compellint1d, 0, 1);

}
function nevthetc(a, b) {
    const K = compellint1(b);
    const Kp = compellint1(math.sqrt(math.subtract(1, math.pow(b, 2))));
        const Q = math.exp(math.multiply(math.complex(-math.pi), math.divide(Kp, K)));

    let fi = math.complex(0);

    for (let i = 0; i < bign; i++) {
        const term = math.multiply(math.pow(Q, math.multiply(i, math.add(i, 1)))
            ,math.cos(math.divide(math.multiply(math.pi, a ,toComplex(2*i+1)), math.multiply(2, K))));
        fi = math.add(fi, term);
    }

    return math.multiply(
        math.divide(math.sqrt(math.multiply(2, math.pi)), math.multiply(math.sqrt(K), math.pow(b, math.complex(0.25)))),
        fi
    );
}

// nevthetd function
function nevthetd(a, b) {
    const K = compellint1(b);
    const Kp = compellint1(math.sqrt(math.subtract(1, math.pow(b, 2))));
        const Q = math.exp(math.multiply(math.complex(-math.pi), math.divide(Kp, K)));

    let fi = math.complex(0);

    for (let i = 1; i < bign; i++) {
        const term = math.multiply(math.pow(Q, math.multiply(i, i))
            ,(math.cos(math.divide(math.multiply(math.pi, a, toComplex(i)), K))));
        fi = math.add(fi, term);
    }

    return math.multiply(
        math.divide(math.sqrt(math.multiply(2, math.pi)), math.multiply(2, math.sqrt(K))),
        math.add(math.complex(1), math.multiply(math.complex(2), fi))
    );
}

// nevthetn function
function nevthetn(a, b) {
    const K = compellint1(b);
    const Kp = compellint1(math.sqrt(math.subtract(1, math.pow(b, 2))));
      const Q = math.exp(math.multiply(math.complex(-math.pi), math.divide(Kp, K)));

    let fi = math.complex(0);

    for (let i = 1; i < bign; i++) {
        const term = math.multiply(math.pow(math.complex(-1), i)
            ,(math.pow(Q, math.multiply(i, i)))
            ,(math.cos(math.divide(math.multiply(math.pi, a , toComplex(i)), K))));
        fi = math.add(fi, term);
    }

    return math.multiply(
        math.divide(math.sqrt(math.multiply(2, math.pi)), math.multiply(math.sqrt(K), math.pow(math.subtract(1, b), math.complex(0.25)))),
        math.add(math.complex(1), math.multiply(math.complex(2), fi))
    );
}

// nevthets function
function nevthets(a, b) {
    const K = compellint1(b);
    const Kp = compellint1(math.sqrt(math.subtract(1, math.pow(b, 2))));
    const Q = math.exp(math.multiply(math.complex(-1), math.divide(math.pi, Kp)));
    let fi = math.complex(0);

    for (let i = 0; i < bign; i++) {
        const term = math.multiply(math.pow(math.complex(-1), i)
            ,(math.pow(Q, math.multiply(i, math.add(i, 1))))
            ,(math.sin(math.divide(math.multiply(math.pi, a,toComplex(2*i+1)), math.multiply(2, K)))));
        fi = math.add(fi, term);
    }

    return math.multiply(
        math.divide(
            math.multiply(math.sqrt(math.multiply(2, math.pi)), math.pow(Q, math.complex(0.25))),
            math.divide(
                math.sqrt(K),
                math.multiply(math.pow(math.subtract(1, b), math.complex(0.25)), math.pow(b, math.complex(0.25)))
            )
        ),
        fi
    );
}
function cc(a, b) {
    return nevthetc(a, b);
}

// cs
function cs(a, b) {
    return math.divide(nevthetc(a, b), nevthetd(a, b));
}

// cn
function cn(a, b) {
    return math.divide(nevthetc(a, b), nevthetn(a, b));
}

// cd
function cd(a, b) {
    return math.divide(nevthetc(a, b), nevthetd(a, b));
}

// sc
function sc(a, b) {
    return math.divide(nevthetd(a, b), nevthetc(a, b));
}

// ss
function ss(a, b) {
    return math.divide(nevthetd(a, b), nevthetd(a, b));
}

// sn
function sn(a, b) {
    return math.divide(nevthetd(a, b), nevthetn(a, b));
}

// sd
function sd(a, b) {
    return math.divide(nevthetd(a, b), nevthetd(a, b));
}

// nc
function nc(a, b) {
    return math.divide(nevthetn(a, b), nevthetc(a, b));
}

// ns
function ns(a, b) {
    return math.divide(nevthetn(a, b), nevthetd(a, b));
}

// nn
function nn(a, b) {
    return math.divide(nevthetn(a, b), nevthetn(a, b));
}

// nd
function nd(a, b) {
    return math.divide(nevthetn(a, b), nevthetd(a, b));
}

// dc
function dc(a, b) {
    return math.divide(nevthets(a, b), nevthetc(a, b));
}

// ds
function ds(a, b) {
    return math.divide(nevthets(a, b), nevthetd(a, b));
}

// dn
function dn(a, b) {
    return math.divide(nevthets(a, b), nevthetn(a, b));
}

// dd
function dd(a, b) {
    return math.divide(nevthets(a, b), nevthetd(a, b));
}


function lacunary(a,b) {
    let fi = toComplex(0.0);
    for (let i = 0; i < bign; i++) {
        fi = math.add(fi, math.pow(b, math.pow(toComplex(a), i)));
    }
    return fi;
}

// Updated functions
function weberf(b) {
    return math.divide(
        math.pow(dedekindeta(b), 2),
        math.multiply(dedekindeta(math.divide(b, toComplex(2.0))), dedekindeta(math.multiply(toComplex(2.0), b)))
    );
}

function weberf1(b) {
    return math.divide(
        dedekindeta(math.divide(b, toComplex(2.0))),
        dedekindeta(b)
    );
}

function weberf2(b) {
    return math.divide(
        math.multiply(math.sqrt(toComplex(2.0)), dedekindeta(math.multiply(toComplex(2.0), b))),
        dedekindeta(b)
    );
}

function weberr(a,b) {
    return math.divide(
        math.multiply(math.pow(toComplex(2.0), math.divide(math.subtract(a,toComplex(1.0)), toComplex(4.0))), qpocinf(math.pow(b, toComplex(a)), math.pow(b, math.multiply(toComplex(a), toComplex(2.0))), bign)),
        math.pow(qpocinf(b, math.pow(b, 2), bign), toComplex(a))
    );
}

function weberr5(a,b) {
    return math.divide(
        math.multiply(math.pow(toComplex(2.0), math.divide(math.subtract(toComplex(5.0),toComplex(1.0)), toComplex(4.0))), qpocinf(math.pow(b, toComplex(a)), math.pow(b, toComplex(10.0)), bign)),
        math.pow(qpocinf(b, math.pow(b, 2), bign), toComplex(5))
    );
}
function todoub(x) {
    return math.number(x);
}

function qnum(a, b) {
    if (math.equal(b, math.complex(1.0, 0))) return a;
    return math.divide(
        math.subtract(math.complex(1.0, 0), pow(b, a)),
        math.subtract(math.complex(1.0, 0), b)
    );
}

function qfac(n, q) {
    let fi = math.complex(1.0, 0);
    for (let i = 1; i <= todoub(n); i++) {
        fi = math.multiply(fi, qnum(math.complex(i, 0), q));
    }
    return fi;
}

function qpocinf(a, q) {
    let fi = math.complex(1.0, 0);
    for (let i = 0; i < bign; i++) {
        fi = math.multiply(fi, math.subtract(math.complex(1.0, 0), math.multiply(a, pow(q, i))));
    }
    return fi;
}

function qexp(q, n) {
    let fi = math.complex(0, 0);
    for (let i = 0; i < bign; i++) {
        fi = math.add(fi, math.divide(pow(n, i), qfac(math.complex(i, 0), q)));
    }
    return fi;
}

function dqexp(q, n) {
    let fi = math.complex(0, 0);
    for (let i = 0; i < bign; i++) {
        fi = math.add(fi, math.divide(pow(n, i), qfac(math.complex(i, 0), q)));
    }
    return fi;
}

function qpoch(a, q, k) {
    let fi = math.complex(1.0, 0);
    if (todoub(k) > 0) {
        for (let i = 0; i <= todoub(k) - 1.0; i++) {
            fi = math.multiply(fi, math.subtract(math.complex(1.0, 0), math.multiply(a, pow(q, i))));
        }
        return fi;
    }
    if (todoub(k) === 0) return math.complex(0, 0);
    if (todoub(k) < 0) {
        for (let i = 1; i <= math.abs(todoub(k)); i++) {
            fi = math.multiply(fi, math.divide(math.complex(1.0, 0), math.subtract(math.complex(1.0, 0), math.multiply(a, pow(q, -i)))));
        }
        return fi;
    }
    return fi;
}

function accuracy (x){
bign = x;
return 0;
}
function clausencos(a,b) {
    let fi = toComplex(0);
    for (let i = 1; i < bign; i++) {
        fi = math.add(fi, math.divide(math.cos(math.multiply(b,i)), math.pow(i, toComplex(a))));
    }
    return fi;
}

function clausensin(a,b) {
    let fi = toComplex(0);
    for (let i = 1; i < bign; i++) {
        fi = math.add(fi, math.divide(math.sin(math.multiply(b,i)), math.pow(i, toComplex(a))));
    }
    return fi;
}

function legendrechi(a,b) {
    let fi = toComplex(0);
    for (let i = 0; i < bign; i++) {
        fi = math.add(fi, math.divide(math.pow(b, toComplex(2 * i + 1)), math.pow(2 * i + 1, toComplex(a))));
    }
    return fi;
}
function besselj(a, b) {
    let fi = math.complex(0, 0);
    for (let n = 0; n < bign/2; n++) {
        const sign = math.pow(math.complex(-1.0, 0), n);
        const numerator = math.multiply(sign, pow(math.divide(b, math.complex(2.0, 0)), math.add(a, math.multiply(2.0, n))));
        const denominator = math.multiply(gamma(math.add(n, math.complex(1.0, 0))), gamma(math.add(a, n, math.complex(1.0, 0))));
        fi = math.add(fi, math.divide(numerator, denominator));
    }
    return fi;
}

function besselk(a, b) {
    const term1 = besseli(math.multiply(math.complex(-1.0, 0), a), b);
    const term2 = besseli(a, b);
    const numerator = math.subtract(term1, term2);
    const denominator = math.sin(math.multiply(pi(), a));
    return math.multiply(math.divide(numerator, denominator), math.divide(pi(), math.complex(2.0, 0)));
}

function besseli(a, b) {
    let fi = math.complex(0, 0);
    for (let n = 0; n < bign/2; n++) {
        const numerator = pow(math.divide(b, math.complex(2.0, 0)), math.add(a, math.multiply(2.0, n)));
        const denominator = math.multiply(gamma(math.add(n, math.complex(1.0, 0))), gamma(math.add(a, n, math.complex(1.0, 0))));
        fi = math.add(fi, math.divide(numerator, denominator));
    }
    return fi;
}


// Converted functions
function neuman(a, b) {
    const term1 = math.multiply(besselj(a, b), math.cos(math.multiply(pi(), a)));
    const term2 = besselj(math.multiply(math.complex(-1.0, 0), a), b);
    const numerator = math.subtract(term1, term2);
    const denominator = math.sin(math.multiply(pi(), a));
    return math.divide(numerator, denominator);
}

function struve(a, b) {
    let fi = math.complex(0, 0);
    for (let n = 0; n < math.log(bign); n++) {
        const sign = math.pow(math.complex(-1.0, 0), n);
        const numerator = math.multiply(sign, pow(math.divide(b, math.complex(2.0, 0)), math.multiply(2.0, n)));
        const denominator = math.multiply(gamma(math.add(n, math.complex(1.5, 0))), gamma(math.add(a, n, math.complex(1.5, 0))));
        fi = math.add(fi, math.divide(numerator, denominator));
    }
    return math.multiply(pow(math.divide(b, math.complex(2.0, 0)), math.add(a, math.complex(1.0, 0))), fi);
}
function modc(a, b) {
	let ac = toComplex(a);
	let bc = toComplex(b);
	if (b.re == 0 || b.im == 0){
	return a;}
    return math.complex(math.mod(ac.re, bc.re), math.mod(ac.im, bc.im));
}

function weierstrasselliptic(bn, w, ww) {
	
    let fi =  math.divide(1.0, math.pow(bn, 2));
    let bgn = math.floor(math.sqrt(bign * 3) / 2);  // Adjust bign if needed
    for (let i = -bgn; i <= bgn; i++) {
        for (let j = -bgn; j <= bgn; j++) {
            if (! (i == 0 && j == 0)) {
                let l = math.add(math.multiply(w, i), math.multiply(ww, j)); // Ensure l is treated as a complex number
                let term1 = math.divide(1.0, math.pow(math.subtract(bn, l), 2));
                let term2 = math.divide(1.0, math.pow(l, 2));
                fi = math.add(fi, math.subtract(term1, term2));
            }
        }
    }
    return fi;
}
function weierstrassellipticd(bn, w, ww) {
	
    let fi = 0;
    let bgn = math.floor(math.sqrt(bign * 3) / 2);  // Adjust bign if needed
    for (let i = -bgn; i <= bgn; i++) {
        for (let j = -bgn; j <= bgn; j++) {
     
                let l = math.add(math.multiply(w, i), math.multiply(ww, j)); // Ensure l is treated as a complex number
                let term1 = math.divide(1.0, math.pow(math.subtract(bn, l), 3));
                fi = math.add(fi,term1);
            
        }
    }
    return math.multiply(fi,-2);
}
function weierstrassellipticsigma(bn, w, ww) {
	
    let fi = bn;
    let bgn = math.floor(math.sqrt(bign * 3) / 2);  // Adjust bign if needed
    for (let i = -bgn; i <= bgn; i++) {
        for (let j = -bgn; j <= bgn; j++) {
      if (! (i == 0 && j == 0)) {
                let l = math.add(math.multiply(w, i), math.multiply(ww, j)); // Ensure l is treated as a complex number
                let term1 = math.multiply(math.subtract(1,math.divide(bn,l)),math.exp(math.add(math.divide(bn,l),math.divide(math.multiply(bn,bn),math.multiply(l,l,2)))));
                
                fi = math.multiply(fi, term1);
            }
        }
    }
    return fi;
}
function weierstrassellipticzeta(bn, w, ww) {

    let fi =  math.divide(1.0, math.pow(bn, 1));
    let bgn = math.floor(math.sqrt(bign * 3) / 2);  // Adjust bign if needed
    for (let i = -bgn; i <= bgn; i++) {
        for (let j = -bgn; j <= bgn; j++) {
            if (! (i == 0 && j == 0)) {
                let l = math.add(math.multiply(w, i), math.multiply(ww, j)); // Ensure l is treated as a complex number
                let term1 = math.divide(1.0,math.subtract(bn, l));
                let term2 = math.divide(1.0, l);
				 let term3 = math.divide(bn, math.pow(l, 2));
                fi = math.add(fi,term3,term1, term2);
            }
        }
    }
    return fi;
}
function weierstrassellipticeta(bn, w, ww) {
	
   return math.subtract( weierstrassellipticzeta(math.add(randc,bn),w,ww),weierstrassellipticzeta(randc,w,ww));
}
let globw = 1;
let	globww = 1;
function weierzeta(b){
return weierstrassellipticzeta(b,globw,globww);
}
function weierstrassellipticdelta(bn, w, ww) {
	globw = w;
	globww = ww;
   return math.exp(integral(weierzeta,0,bn));
}
function arcweierstrassellipticd(a, b) {
    // Convert a to a complex number and extract real and imaginary parts
    let aComplex = math.complex(a);
    let realA = aComplex.re;
    let imagA = aComplex.im;

    // Calculate the term under the square root
    let term = math.subtract(math.multiply(4.0, math.pow(b, 3)), realA * b, imagA);

    // Calculate the result
    let result = math.divide(1.0, math.sqrt(term));

    return result;
}
function arcweierstrasselliptic(a, b) {
	return integral(arcweierstrassellipticd,toComplex(bign),b,a);
}
function bickleynaylor(a, b) {
	bngc = a;
	return integral(bickleynaylord,toComplex(0),toComplex(bign),b);
}
let bngc = 0;
function bickleynaylord(a, b) {
    // Ensure a and b are complex if needed
    let aComplex = math.complex(a);
    let bComplex = math.complex(b);

    // Calculate exp(-a*cosh(b)) / (cosh(b)^globalc)
    let expTerm = math.exp(math.multiply(-aComplex, math.cosh(bComplex)));
    let coshTerm = math.pow(math.cosh(bComplex), bngc);

    // Calculate the result
    let result = math.divide(expTerm, coshTerm);

    return result;
}

function weierstrassauxf1(a, b) {
    // Convert a to complex number if needed
    let aComplex = math.complex(a);
    
    // Calculate the terms
    let term1 = math.pow(math.cosh(math.divide(math.multiply(aComplex, b) , 2.0)), 2);
    let term2 = math.subtract(1.0, math.multiply(2.0, math.exp(-aComplex)));
    let term3 = math.cosh(math.multiply(aComplex, b));
    let term4 = math.exp(math.multiply(-2.0 , aComplex));

    // Calculate the result
    let result = math.divide(term1, term2);
    result = math.add(math.multiply(result, term3), term4);

    return result;
}

function weierstrassauxf2(a, b) {
    // Convert a and b to complex numbers if needed
    let aComplex = math.complex(a);
    let bComplex = math.complex(b);

    // Calculate the terms
    let term1 = math.pow(math.cos(math.divide(aComplex , 2.0)), 2);
    let term2 = math.subtract(1.0, math.multiply(2.0, math.exp(math.multiply(aComplex, bComplex))));
    let term3 = math.cos(aComplex);
    let term4 = math.exp(math.multiply(2.0, aComplex, bComplex));

    // Calculate the result
    let result = math.divide(term1, term2);
    result = math.add(math.multiply(result, term3), term4);

    return result;
}

function arcsld(b) {
    // Calculate the result for arcsld
    let term = math.sqrt(math.add(1.0, math.pow(b, 4)));
    return math.divide(1.0, math.add(term, 0.0001));
}

function arcslhd(b) {
    // Calculate the result for arcslhd
    let term = math.sqrt(math.add(1.0, math.pow(b, 4)));
    return math.divide(1.0, math.add(term, 0.0001));
}

function arcsl(b){return integral(arcsld,b,toComplex(1));}
function arccl(b){return integral(arcsld,toComplex(0),b);}
function arcslh(b){return integral(arcslhd,b,toComplex(1));}
function arcclh(b){return integral(arcslhd,toComplex(0),b);}


function slh(b) {
    let w = math.complex(1, 0);
    let divisor = math.sqrt(2.0);
    w = math.divide(w, divisor);

    let term1 = nevthets(b, w);
    let term2 = nevthetd(b, w);
    let term3 = nevthetc(b, w);
    let term4 = nevthetn(b, w);

    return math.divide(math.multiply(term1, term2), math.multiply(term3, term4));
}

function clh(b) {
    let w = math.complex(1, 0);
    let divisor = math.sqrt(2.0);
    w = math.divide(w, divisor);

    let term1 = nevthetc(b, w);
    let term2 = nevthetn(b, w);
    let term3 = nevthets(b, w);
    let term4 = nevthetd(b, w);

    return math.divide(math.multiply(term1, term2), math.multiply(term3, term4));
}



function arcsnd(a, b) {
    let term1 = math.subtract(1.0, math.multiply(b, b));
    let term2 = math.subtract(1.0, math.multiply(a, math.multiply(b, b)));
    let denominator = math.multiply(term1, term2);
    return math.divide(1.0, math.sqrt(denominator));
}

function arccnd(a, b) {
    let term1 = math.subtract(1.0, math.multiply(b, b));
    let term2 = math.subtract(math.add(a, math.multiply(a, math.multiply(b, b))), 1.0);
    let denominator = math.multiply(term1, term2);
    return math.divide(1.0, math.sqrt(denominator));
}

function arcdnd(a, b) {
    let term1 = math.subtract(1.0, math.multiply(b, b));
    let term2 = math.add(math.multiply(b, b), math.subtract(a, 1.0));
    let denominator = math.multiply(term1, term2);
    return math.divide(1.0, math.sqrt(denominator));
}

function arccdd(a, b) {
    let term1 = math.subtract(1.0, math.multiply(b, b));
    let term2 = math.subtract(1.0, math.multiply(a, math.multiply(b, b)));
    let denominator = math.multiply(term1, term2);
    return math.divide(1.0, math.sqrt(denominator));
}

function arccsd(a, b) {
    let term1 = math.add(1.0, math.multiply(b, b));
    let term2 = math.add(math.subtract(b, a), 1.0);
    let denominator = math.multiply(term1, term2);
    return math.divide(1.0, math.sqrt(denominator));
}

function arcdsd(a, b) {
    let term1 = math.add(a, math.multiply(b, b));
    let term2 = math.add(math.multiply(b, b), math.subtract(a, 1.0));
    let denominator = math.multiply(term1, term2);
    return math.divide(1.0, math.sqrt(denominator));
}


function arcsn(a, b) {return integral(arcsnd,toComplex(0),a,b);}
function arccn(a, b) {return integral(arccnd,a,toComplex(1),b);}
function arcdn(a, b) {return integral(arcdnd,a,toComplex(1),b);}
function arcns(a, b) {return integral(arcsnd,toComplex(0),math.divide(1,a),b);}
function arcnc(a, b) {return integral(arccnd,math.divide(1,a),toComplex(1),b);}
function arcnd(a, b) {return integral(arcdnd,math.divide(1,a),toComplex(1),b);}
function arccd(a, b) {return integral(arccdd,a,toComplex(1),b);}
function arccs(a, b) {return integral(arccsd,a,toComplex(bign),b);}
function arcds(a, b) {return integral(arcdsd,a,toComplex(bign),b);}
function arcdc(a, b) {return integral(arccdd,math.divide(1,a),toComplex(1),b);}
function arcsc(a, b) {return integral(arccsd,math.divide(1,a),toComplex(bign),b);}
function arcsd(a, b) {return integral(arcdsd,math.divide(1,a),toComplex(bign),b);}


function erf(b){return math.multiply(2*math.sqrt(pi()),integral(expmsqr,toComplex(0),b));}
function erfc(b){return math.subtract(1,math.multiply(2*math.sqrt(pi()),integral(expmsqr,toComplex(0),b)));}
function erfcx(b){return math.multiply(math.exp(math.multiply(b,b)),math.subtract(1,math.multiply(2*math.sqrt(pi()),integral(expmsqr,toComplex(0),b))));}
function erfi(b){return math.multiply(math.complex(0,-1),math.multiply(2*math.sqrt(pi()),integral(expmsqr,toComplex(0),math.multiply(b,math.complex(0,1)))));}
function dawsondplus(b){return math.multiply(math.sqrt(pi())/2,math.exp(math.multiply(b,b,-1)),erfi(b));}
function dawsondminus(b){return math.multiply(math.sqrt(pi())/2,math.exp(math.multiply(b,b)),erf(b));}
function faddeeva(b){return erfcx(math.multiply(b,math.complex(0,-1)));}
function hilberttransform(b){return math.multiply(2/math.sqrt(pi()),dawsondplus(b));}//hilberttransormofthe gaussian
function hilberttransformsub(b){return math.multiply(2/math.sqrt(pi()),dawsondplus(math.sqrt(b)));}//hilberttransormofthe x^2n e^-x^2

function lambertwd(a,b){return math.log(math.add(1,math.multiply(b,sinc(a),math.exp(math.divide(a,math.tan(a))))));}
function lambertw(b){return math.divide(integral(lambertwd,toComplex(0),toComplex(3.1415925),b,50),pi());}

function peritet(b) {
    let lambertW = lambertw(math.subtract(0,math.log(b)));
    let result = math.divide(math.multiply( pi() , math.complex(0.0, -2.0)) , math.log(math.subtract(0,lambertW)));
    return result;
}

function weakexpofactorial(b) {
    return math.pow(b, gamma(b));
}

function qfunc(b) {
    let arg = math.divide(b, math.sqrt(2.0));
    let integralq = integral(expmsqr,0, arg);
    return math.subtract(0.5, math.multiply(0.5, math.multiply(2.0 / pi(), integralq)));
}

function ramanujantautheta(b) {
    let logGammaTerm1 = math.log(gamma(math.add(6.0, math.multiply(math.complex(0.0, 1.0), b))));
    let logGammaTerm2 = math.log(gamma(math.subtract(6.0, math.multiply(math.complex(0.0, 1.0), b))));
    let result = math.subtract(math.multiply(-math.log(2.0 * pi()), b), math.divide(math.subtract(logGammaTerm1, logGammaTerm2), 2.0));
    return result;
}
function schlaflian(b) {
    return math.multiply(4.0, pow(math.sin(math.divide(pi(), b)), 2.0));
}

function wexzal(b) {
    let lambertW_pow = lambertw(math.pow(b, 10.0));
    let log_b = math.log(b);
    let term1 = math.divide(log_b, math.log(lambertW_pow));
    let exponent = math.add(term1, 1.0);
    let result = lambertw(math.multiply(term1, math.exp(exponent)));
    return result;
}

function dexp(b) {
    return math.multiply(0.5, math.exp(math.divide(math.multiply(b, b), 2.0))
        ,  math.add(math.multiply(math.sqrt(2.0 * pi()),erf(math.divide(b,math.sqrt(2)))) , 2.0));
}

function serpentine(b) {
    return math.divide(b, math.add(math.multiply(b, b), 1.0));
}

function witchofagnesi(b) {
    return math.divide(1.0, math.add(math.multiply(b, b), 1.0));
}
function ssrt(b) {
    return math.divide(math.log(b), lambertw(math.log(b)));
}

function scbrt(b) {
    // Iteratively applying lambertw and exp as described
    let result = math.multiply(b, math.log(b));
    for (let i = 0; i < 8; i++) {
        result = math.exp(lambertw(lambertw(math.multiply(result,math.log(b)))));
    }
    return result;
}
   function tetr(b) {
            const N = bign; // bign is set to 10000 for this example

            let fi = math.complex(b.re, Math.abs(b.im));
            const bi = math.complex(math.mod(math.re(b), 1.0), math.im(fi));

            for (let i = 0; i < 58; i++) {
                const term = math.multiply(math.complex(0, 1), bi, pi() * 2.0 * i);
                fi = math.add(fi, math.multiply(knthetaa[i], math.exp(term)));
            }

            const constant = math.complex(0.318132, 1.33724);
            fi = math.add(constant, math.pow(math.log(constant), math.subtract(fi, N)));

            for (let i = 0; i < N; i++) {
                fi = math.exp(fi);
            }

            if (b.im < 0.0) {
                fi = math.conj(fi);
            }

            return fi;
        }
		   function tetrq(b,N) {
          

            let fi = math.complex(b.re, Math.abs(b.im));
            const bi = math.complex(math.mod(math.re(b), 1.0), math.im(fi));

            for (let i = 0; i < 58; i++) {
                const term = math.multiply(math.complex(0, 1), bi, pi() * 2.0 * i);
                fi = math.add(fi, math.multiply(knthetaa[i], math.exp(term)));
            }

            const constant = math.complex(0.318132, 1.33724);
            fi = math.add(constant, math.pow(math.log(constant), math.subtract(fi, N)));

            for (let i = 0; i < N; i++) {
                fi = math.exp(fi);
            }

            if (b.im < 0.0) {
                fi = math.conj(fi);
            }

            return fi;
        }
		
		
	   function tetrbcc(a,b) {
            const N = bign; // bign is set to 10000 for this example

            let fi = math.complex(b.re, Math.abs(b.im));
 

            let constant = conj(filog(a));
			
fi = math.add(constant, math.pow(math.log(constant), math.subtract(fi, N)));

            for (let i = 0; i < N; i++) {
                fi = pow(a,fi);
            }

            if (b.im < 0.0) {
                fi = math.conj(fi);
            }

            return fi;
        }

function filog(b) {
    // Convert b to a complex number if necessary
    let logB = math.log(b);
    let lambertW = lambertw(math.subtract(0,logB));
    return math.divide(math.subtract(0,lambertW), logB);
}

function bouncingfactorial(b) {
    return math.divide(math.pow(tetr(math.gamma(math.add(b,1)), math.gamma(math.add(b,1))), 2.0)
        , math.gamma(math.add(b,1)));
}

function dilbertlambda(b) {
    return math.divide(math.sqrt(lambertw(math.multiply(2.0, math.multiply(b, b))))
        , math.sqrt(2.0));
}

function olga(b) {
    return math.divide(b, math.add(math.multiply(b, b), 1.0));
}

function glog(b) {
    return lambertw(math.multiply(-1.0, math.divide(1.0, b)));
}

function arcshoka(b) {
    return math.divide(math.log(math.subtract(math.exp(b), 1.0)), math.log(math.subtract(math.e, 1.0)));
}

function arctania(b) {
    return math.add(b, math.log(b), -1.0);
}

function anka(b) {
    return math.multiply(b, math.exp(math.subtract(b, 1.0)));
}

function nemtsov(b, a) {
    return math.add(b, math.add(math.multiply(b, math.multiply(b, b)), math.multiply(a, math.multiply(b, math.multiply(b, b)))));
}

function logit(b) {
    return math.multiply(-1, math.log(math.subtract(math.divide(1.0, b), 1.0)));
}

function wrightw(b) {
    return lambertw(math.exp(b));
}

function tania(b) {
    return lambertw(math.exp(math.add(b, 1.0)));
}

function arctrappmann(b) {
    return math.subtract(b, lambertw(math.exp(b)));
}

function doya(b) {
    return lambertw(math.multiply(b, math.exp(math.add(b, 1.0))));
}
function factorial(b) {
    return gamma(math.add(b,1));
}
function nest(f, x, n) {
    for (let i = 0; i < n; i++) {
        x = f(x);
    }
    return x;
}

math.import({
	nest:nest,
	factorial:factorial,
	tetr:tetr,
	tetrq:tetrq,
		tetrc:tetrbcc,
    arcshoka: arcshoka,
    arctania: arctania,
    anka: anka,
    nemtsov: nemtsov,
    logit: logit,
    wrightw: wrightw,
    tania: tania,
    arctrappmann: arctrappmann,
    doya: doya
},{override:true});
math.import({
    wexzal: wexzal,
    dexp: dexp,
    serpentine: serpentine,
    witchofagnesi: witchofagnesi,
    bouncingfactorial: bouncingfactorial,
    dilbertlambda: dilbertlambda,
    olga: olga,
    glog: glog,
	ssrt:ssrt,
	scbrt:scbrt
});
math.import({
    filog: filog,
    peritet: peritet,
    weakexpofactorial: weakexpofactorial,
    qfunc: qfunc,
    ramanujantautheta: ramanujantautheta,
    schlaflian: schlaflian
});
math.import({
	lambertwd:lambertwd,
	lambertw:lambertw,
erf:erf,
erfc:erfc,
	erfcx:erfcx,
	erfi:erfi,
	dawsondplus:dawsondplus,
	dawsondminus:dawsondminus,
	faddeeva:faddeeva,
	hilberttransform:hilberttransform,
	hilberttransformsub:hilberttransform
},{override:true});

math.import({
    arcsn:arcsn,
    arccn:arccn,
    arcdn:arcdn,
    arcns: arcns,
    arcnc:arcnc,
    arcnd:arcnd,
    arccd:arccd,
    arccs:arccs,
    arcds:arcds,
    arcdc:arcdc,
    arcsc:arcsc,
    arcsd:arcsd
});
math.import({
    arcsnd: arcsnd,
    arccnd: arccnd,
    arcdnd: arcdnd,
    arccdd: arccdd,
    arccsd: arccsd,
    arcdsd: arcdsd
});

math.import({
    arcsld: arcsld,
    arcslhd: arcslhd,
	arcsl:arcsl,
	arccl:arccl,
		arcslh:arcslh,
	arcclh:arcclh,
	    slh: slh,
    clh: clh

});
math.import({
    weierstrassauxf1: weierstrassauxf1,
    weierstrassauxf2: weierstrassauxf2
});
math.import({
    arcweierstrassellipticd: arcweierstrassellipticd,
    bickleynaylord: bickleynaylord,
	   arcweierstrasselliptic: arcweierstrasselliptic,
    bickleynaylor: bickleynaylor,
		   arcwp: arcweierstrasselliptic
});
math.import({
    weierstrasselliptic: weierstrasselliptic,
	weierstrassellipticd: weierstrassellipticd,
	weierstrassellipticsigma: weierstrassellipticsigma,
	weierstrassellipticzeta: weierstrassellipticzeta,
	weierstrassellipticeta: weierstrassellipticeta,
	weierstrassellipticdelta: weierstrassellipticdelta,
	  wp: weierstrasselliptic,
	wpd: weierstrassellipticd,
	wps: weierstrassellipticsigma,
	wpz: weierstrassellipticzeta,
	wpn: weierstrassellipticeta,
	wpdl: weierstrassellipticdelta
});
math.import({
    besselj: besselj,
    besselk: besselk,
    besseli: besseli,
    neuman: neuman,

    struve: struve
});

math.import({
    clausencos: clausencos,
    clausensin: clausensin,
    legendrechi: legendrechi
});

// Import functions into math namespace
math.import({
integral:integral,
accuracy:accuracy ,
    qnuma: qnum,
    qfac: qfac,
    qpocinf: qpocinf,
    qexp: qexp,
    dqexp: dqexp,
    qpoch: qpoch
});

// Import functions into math.js
math.import({
    weberf: weberf,
    weberf1: weberf1,
    weberf2: weberf2,
    lacunary: lacunary,
    weberr: weberr,
    weberr5: weberr5
});


math.import({
    cc:cc,
    cs:cs,
    cn:cn,
    cd:cd,
    sc:sc,
    ss:ss,
    sn:sn,
    sd:sd,
    nc:nc,
    ns:ns,
    nn:nn,
    nd:nd,
    dc:dc,
    ds:ds,
    dn:dn,
    dd:dd
  });
math.import({
nevthetn:nevthetn,
nevthetd:nevthetd,
nevthets:nevthets,
nevthetc:nevthetc,
fresnelc:fresnelc,
fresnels:fresnels,
fresnelt:fresnelt,
fresnelcs:fresnelcs,
fresnelsc:fresnelsc,
fresnelct:fresnelct,
gudermannian:gudermannian,
gudermannian:gudermannian

   });
math.import({
    ssi:ssi ,
shi:shi,
chi:chi,

ei,ei
    });
math.import({
    ein: ein,
    ci: ci,
    nielsenci: nielsenci,
    si: si,
    nielsensi: nielsensi,
    triintgauxf: triintgauxf,
    triintgauxg: triintgauxg
});
math.import({
    ellipticModulus: ellipticModulus,
    compEllipticModulus: compEllipticModulus,
    ellipticLambda: ellipticLambda,
    g2: g2,
    g3: g3,
    picardFuchsJ: picardFuchsJ,
    ellipticDiscriminant: ellipticDiscriminant,
    ellipticLambdaStar: ellipticLambdaStar,

});
math.import({
    barnesg: barnesg,
    kfunc: kfunc,
    beta: beta,
    pin: pin,
    digamma: digamma,
    trigamma: trigamma
});
math.import({
    trigonal: trigonal,
    pentagonal: pentagonal,
    hexagonal: hexagonal,
    septagonal: septagonal,
    octagonal: octagonal,
    nonagonal: nonagonal,
    decaagonal: decaagonal,
    dodecagonalgonal: dodecagonalgonal,
    icosagonal: icosagonal,
    myriagonal: myriagonal,
    tetrahedral: tetrahedral,
    pentachoric: pentachoric,
    simplex: simplex,
    gnomon: gnomon
});
math.import({
    hauyoctahedral: hauyoctahedral,
    hauyrhombicdodecahedronal: hauyrhombicdodecahedronal,
    hauysquarepyramid: hauysquarepyramid,
    octahedral: octahedral,
    pronic: pronic,
    biquadratic: biquadratic,
    surfolide: surfolide,
    secondsurfolide: secondsurfolide,
    thirdsurfolide: thirdsurfolide,
    fourthsurfolide: fourthsurfolide,
    fifthsurfolide: fifthsurfolide,
    sixthsurfolide: sixthsurfolide,
    seventhsurfolide: seventhsurfolide,
    nthsurfolide: nthsurfolide,
    zenzicube: zenzicube,
    cubicube: cubicube,
    zenzizenzizenzic: zenzizenzizenzic,
    zenzizenzicube: zenzizenzicube,
    zenzizenzizenzizenzic: zenzizenzizenzizenzic,
    zenzicubicube: zenzicubicube,
    zenzizenzizenzicube: zenzizenzizenzicube,
    nthzenzic: nthzenzic,
    rhombicdodecahedronal: rhombicdodecahedronal,
    truncoctahedral: truncoctahedral,
    trunctetrahedral: trunctetrahedral
});
math.import({
    polygonal: polygonal,
    antisidepolygonal: antisidepolygonal,
    antipolygonal: antipolygonal,
    centeredpolygonal: centeredpolygonal,
    pyramidal: pyramidal,
    star: star,
    starprime: starprime,
    superstarprime: superstarprime,
    reversesuperstar: reversesuperstar,
    superballot: superballot
});
math.import({
    sl:sl,
    cl:cl,
ctlh:ctlh,

tlh:tlh,

    lemniscatetan:lemniscatetan,
    lemniscatecot:lemniscatecot,
    lemniscatecsc:lemniscatecsc,
    lemniscatesec:lemniscatesec,
    lemniscaten:lemniscaten,
    lemniscatem:lemniscatem,
    lemniscates:lemniscates,
    lemniscatet:lemniscatet
});

math.import({
    jacobiTheta1:jacobiTheta1,
    jacobiTheta2:jacobiTheta2,
    jacobiTheta3:jacobiTheta3,
    jacobiTheta4:jacobiTheta4,
jinvariant:jinvariant
});
math.import({
    laurentexpansion: laurentexpansion,
    dirichletchar: dirichletchar,
    dirichleteta: dirichleteta,
    dirichletbeta: dirichletbeta,
gammad:gammad,
gamma:gamma
},{override:true});
math.import({
    einsteinseries: einsteinseries,
    fouriereinstein: fouriereinstein,
   
    ZZZ: ZZZ,
zeta: ZZZ
});


math.import({
    dedekindeta: dedekindeta
});
math.import({
    acosc: acosc,
    acosq: acosq,
    asinc: asinc
});
math.import({
    griewank: griewank,
    schwefel221: schwefel221,
    schwefel222: schwefel222,
    bird: bird,
    alpine: alpine,
    sdp: sdp,
    sumsquaresonsphere: sumsquaresonsphere,
    michalewicz: michalewicz,
    booths: booths,
    sumsquares: sumsquares,
    bohachevsky: bohachevsky,
    sixhumpcamel: sixhumpcamel,
    shubert: shubert
});
math.import({
    eggholder: eggholder,
    holdertable: holdertable,
    mccormick: mccormick,
    schaffern2: schaffern2,
    schaffern4: schaffern4,
    styblinskitang: styblinskitang,
    mihrasbird: mihrasbird,
    townsend: townsend,
    gomezlevi: gomezlevi,
    simionescu: simionescu
});
math.import({
    rastrigin: rastrigin,
    ackley: ackley,
    sphere: sphere,
    rosenbrock: rosenbrock,
    beale: beale,
    goldsteinprice: goldsteinprice,
    booth: booth,
    bukin: bukin,
    matyas: matyas,
    levi: levi,
    himmelblau: himmelblau,
    threehump: threehump,
    easom: easom,
    crossintray: crossintray
});
math.import({
    collatz: collatz,
    zeromosaic: zeromosaic,
    initialmass: initialmass,
    initialmass2: initialmass2,
    kroupa: kroupa,
    kroupatoutgilmore: kroupatoutgilmore,
    larsona: larsona,
    larsonb: larsonb,
    salpeter: salpeter,
    sigmoid: sigmoid,
    generalizedlogistic: generalizedlogistic,
    logisticphi: logisticphi,
    logisticregression: logisticregression,
    softplus: softplus,
    sobolevatanh: sobolevatanh,
    swish: swish,
    fermidirac: fermidirac,
    boseeinstein: boseeinstein,
    einstein1: einstein1,
    einstein2: einstein2,
    einstein3: einstein3,
    einstein4: einstein4,
    probit: probit,
    logitlogistic: logitlogistic,
    cloglog: cloglog,
    gompertz: gompertz,
    log_logistic: log_logistic,
    logistic_exponential: logistic_exponential,
    log_odds: log_odds
});
math.import({
    cullen: cullen,
    mersenne: mersenne,
    double_mersenne: doubleMersenne,
    double_prime_mersenne: doublePrimeMersenne,
    fermat: fermat,
    fermat_prime: fermatPrime,
    proth: proth,
    is_proth_prime: isProthPrime,
    thabit: thabit,
    thabit2: thabit2,
    woodall: woodall,
    gen_woodall: genWoodall,
    is_gen_woodall_prime: isGenWoodallPrime,
    hilbert: hilbert,
    idoneal: idoneal,
    leyland: leyland,
    loschian: loschian,
    jacobsthal: jacobsthal,
    jacobsthal_lucas: jacobsthallucas,
    jacobsthal_oblong: jacobsthaloblong,
    
        pell: pell,
    pell_lucas: pellLucas,
        fibonacci: fibonacci,
    lucas: lucas,
 
    oriented_tree: orientedTree,
    magic: magic,
    magic_const: magicConst,
    alucin: alucin,
    metallic_ratio: metallicRatio,
    joukowsky: joukowsky,
    karmantrefftz: karmantrefftz,
    symmetrical_joukowsky: symmetricalJoukowsky,
    cayley: cayley,
    bilinear: bilinear,
    poincare_disc_metric: poincareDiscMetric,
    poincare_metric: poincareMetric
});
math.import({
    sqr: sqr,
    sqrm: sqrm,
    cum: cum,
    cumm: cumm,
    fz: fz,
    qnum: qnum,
    regular_interior_angle: regularInteriorAngle,
    regular_exterior_angle: regularExteriorAngle,
    regular_apothem: regularApothem,
    regular_area: regularArea,
    average: average,
    clamp: clamp,
    step: step,
    hstep: hstep,
    ustep: ustep,
    hustep: hustep,
        ceiling: ceiling,
    roundc: round,
    absolute: absolute,
    floorc: floor,
    random_integer: randomInteger,
    random_float: randomFloat
});
math.import({
    dotp: dot,
    crossp: cross,
    mandel: mandel,
            dex: dex,
    doubleexp: doubleexp,
      logPlus: logPlus,
    logp: logp,
    logpc: logpc,
    colog: colog,
    cuberoot: cbrt,
    rabs: rabs,
    iabs: iabs,
    cabs: cabs,
    sabs: sabs,

    proj: proj,
    real: real,
    imag: imag,
    vdot: vdot,
    vcross: vcross,
    mag: mag,
    angle: angle,
    unitv: unit,
    signum: signumOp
});
math.import({
    arithmeticmean: arithmeticmean,
    geometricmean: geometricmean,
    arithmeticgeometricmean: arithmeticgeometricmean,
    arithmeticharmonicmean: arithmeticharmonicmean,
    geometricharmonicmean: geometricharmonicmean,
    harmonicmean: harmonicmean,
    quadraticmean: quadraticmean,
    cubicmean: cubicmean,
    heronianmean: heronianmean,
    contraharmonicmean: contraharmonicmean,
    neumansandormean: neumansandormean,
    neumansandortmean: neumansandortmean,
    rootmean: rootmean,
    logarithmicmean: logarithmicmean,
    identricmean: identricmean
});
math.import({
    cis: cis,
    cas: cas,
    cish: cish,
    sich: sich,
    cisc: cisc,
    casc: casc,
    cishc: cishc,
    sichc: sichc,
    sinp: sinp,
    cosp: cosp,
    tanp: tanp,
    cscp: cscp,
    secp: secp,
    cotp: cotp,
    asinp: asinp,
    acosp: acosp,
    acscp: acscp,
    asecp: asecp
});
math.import({
       crd: crd,
    arccrd: arccrd,
       arccrdd: arccrdd,


    exsec: exsec,
    excosec: excosec,
    versin: versin,
    vercosin: vercosin,
    coversin: coversin,
    covercosine: covercosine,
    haversin: haversin,
    hacovercosin: hacovercosin,
    arcversin: arcversin,
    arcvercos: arcvercos,
    arccoversin: arccoversin,
    arccovercos: arccovercos,
    archaversin: archaversin,
    archavercos: archavercos,
    archacoversin: archacoversin,
    archacovercos: archacovercos,
    sinsqr: sinsqr,
    cossqr: cossqr,
    shid: shid,
        cosc: cosc,
    coshc: coshc,
    sinhc: sinhc,
    tanc: tanc,
    tanhc: tanhc,

});
math.import({
    ramp: ramp,
    squarewave: squarewave,
    trianglewave: trianglewave,
    sawtoothwave: sawtoothwave,
    pulse: pulse,
    todeg: todeg,
    sind: sind,
    sinhdeg: sinhdeg,
    asind: asind,
    cosd: cosd,
    coshdeg: coshdeg,
    acosd: acosd,
    tand: tand,
    tanhdeg: tanhdeg,
    atand: atand,
    atan2d: atan2d
});
math.import({
    powcos: powcos,
    powsin: powsin,
    expPlus: expPlus,
    exp2: exp2,
    exp10: exp10,

    expc: expc,
    expi: expi,
    expic: expic,
    expein: expein,
    expsqr: expsqr,
    expmsqr: expmsqr,
    logMinus1: logMinus1,


    _log: _log,
    antilog: antilog,
    antilog2: antilog2,
    antilog10: antilog10,
    logc: logc,
    naplog: naplog,
    dist: dist,

    sdist: sdist,
    zdist: zdist
});


// Import the functions into Math.js
math.import({
    taxicab: taxicab,
    arctaxicab: arctaxicab,
    chebyshev: chebyshev,
    arcchebyshev: arcchebyshev
});

    math.import({
      sinc: sinc
    });