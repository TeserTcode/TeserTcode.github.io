<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Domain Coloring</title>
    <style>
          body {
background-color: #bbd;
            font-family: Cambria math, serif;
            margin: 5px;
            text-align: center;

        }
      
        input, button {
            margin: 5px;
            padding: 5px;
        }

        .form-group {
            margin-bottom: 1px;
 font-size: 16px;
        }
        h2 {
             box-shadow:  gray 0px 0px 60px -6px; 
        }
 h1 {
             box-shadow:  #222 0px 0px 60px -6px; 
        }
        #canvasContainer {
 padding: 10px;
            width: 300px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
         position: fixed;
 right:calc(25% - 160px);top:160px;


        }
		#graphContainera {
 padding: 10px;
            width: 300px;
            height: 300px;
           
            align-items: center;
            justify-content: center;
            margin-left: auto;
  margin-right: auto;
  right:calc(25% - 00px);top:160px;
  display:none;
 
position: fixed;
        }
			#graphContainer {
 padding: 10px;
            width: 300px;
            height: 300px;
           
            align-items: center;
            justify-content: center;
            margin-left: auto;
  margin-right: auto;
  right:calc(25% - 160px);top:160px;
  display:none;
 
position: fixed;
        }	
 
.split {
  height: 100%;
  width: 50%;
  position: fixed;
  z-index: 1;
  overflow-x: hidden;
  padding-top: 20px;

}

.gold{
   border-left: 5px gold;
}

.left {
  left: 0;
 border: 5px solid #000;
background-color: #eee;
 border-top: 10px solid black;
box-shadow: inset gray 0px 0px 60px -6px; 


}

.right {
  right: 0;
 border: 5px solid #000;
background-color: #eeeeee;
 border-top: 10px solid  black;
 box-shadow: inset gray 0px 0px 60px -6px; 



}
        .color-input {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 1px solid #ddd;
            cursor: pointer;
        }
        .palette-container {
            display: grid;
            gap: 3px;
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.0.1/math.min.js"></script>
</head>
<body>
    <h1>Complex Domain Coloring</h1>
<div class="split left">
    <div class="form-group">
        <label for="function">Function (e.g., '2^x'):</label>
        <input type="text" id="function" name="function" value="2^x" required>
    </div>
    <div class="form-group">
        <label for="min-real">Min Real:</label>
        <input type="number" id="min-real" name="min-real" step="any" value="-7" required>
        <label for="max-real">Max Real:</label>
        <input type="number" id="max-real" name="max-real" step="any" value="7" required>
    </div>
    <div class="form-group">
        <label for="min-imag">Min Imaginary:</label>
        <input type="number" id="min-imag" name="min-imag" step="any" value="-7" required>
        <label for="max-imag">Max Imaginary:</label>
        <input type="number" id="max-imag" name="max-imag" step="any" value="7" required>
    </div>
    <div class="form-group">
        <label for="bmp-width">BMP Width:</label>
        <input type="number" id="bmp-width" name="bmp-width" step="1" value="100" required>
        <label for="bmp-height">BMP Height:</label>
        <input type="number" id="bmp-height" name="bmp-height" step="1" value="100" required>
    </div>
    <div class="form-group">
        <label for="magnitude-to-lightness">Magnitude to Lightness Conversion:</label>
        <input type="text" id="magnitude-to-lightness" name="magnitude-to-lightness" value="log(1+x)" required>
    </div>
    <div class="form-group">
        <label for="color-mode">Color Mode:</label>
        <select id="color-mode" name="color-mode">
            <option value="hsv">HSV</option>
            <option value="hsl">HSL</option>
            <option value="hcl">HCL</option>
			 <option value="ycbcr">YCbCr</option>
			  <option value="ydbdr">YDbDr</option>
			   <option value="ycocg">YCoCg</option>
			    <option value="ypbpr">YPbPr</option>
            <option value="cielch">CIELCH</option>
	    <option value="2d">2d</option>
		  <option value="contour">Contour</option>
		   <option value="isolines">Isolines</option>
		   <option value="neon">Neon</option>
		   <option value="differ">Differ</option>
            <option value="palette">Palette</option>
        </select>
    </div>
    <div id="palette-group" class="form-group" style="display: none;">
        <label for="palette-file">Select Palette BMP (360x100):</label>
        <input type="file" id="palette-file" accept=".bmp">
        <div>
            <label for="rows">Rows:</label>
            <input type="number" id="rows" name="rows" min="1" value="3">
            <label for="columns">Columns:</label>
            <input type="number" id="columns" name="columns" min="1" value="3">
            <button onclick="generatePaletteInputs()">Generate Inputs</button>
        </div>
        <div id="palette-generator" class="palette-container"></div>
        <button onclick="generatePalette()">Generate Palette</button>
    </div>
    <div class="form-group">
        <label for="saturation-chroma">Saturation/Chroma:</label>
        <input type="range" id="saturation-chroma" name="saturation-chroma" min="0" max="100" value="100">
    </div>
    <div class="form-group">
        <label for="lightness">Lightness:</label>
        <input type="range" id="lightness" name="lightness" min="0" max="100" value="50">
    </div>
    <div class="form-group">
        <label for="hue">Hue:</label>
        <input type="range" id="hue" name="hue" min="0" max="360" value="0">
    <button id="createMeshButton">Create Mesh and Animate</button>
	</div>
    <button onclick="renderBMP()">Generate</button></div>
	 
   <div class="split right">
       <div id="canvasContainer">
        <canvas id="bmpCanvas" width="320" height="320"></canvas>
    </div>
		 <div id="graphContainera">
        <canvas id="graphCanvasa" width="320" height="320"></canvas>
		 
    </div>
    <div id="graphContainer">
        <canvas id="graphCanvas" width="320" height="320"></canvas>
		  <div><div id="coordinate-container"></div></div>
    </div>
<button onclick="change()" style="position: fixed; top: 70%; right: 25%;">></button>
   </canvas></div></div>
   
<script src="clrspc.js"></script>
<script src="mthfnc.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let paletteImageData = null;
	const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 300);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(300,300);
document.body.appendChild(renderer.domElement);
document.getElementById('graphContainera').appendChild(renderer.domElement);
// Create geometry and material placeholders
let mesh;
let geometry;
let material;
const gridSize = 200;  // Resolution of the grid
let page=0;

function change(){
page = math.mod(page+1,3);
 const canvasa = document.getElementById('canvasContainer');
  const canvasb = document.getElementById('graphContainer');
   const canvasc = document.getElementById('graphContainera');
 canvasa.style.display = `none`;
  canvasb.style.display = `none`;
   canvasc.style.display = `none`;
 
 if(page==0) canvasa.style.display = `flex`;
  if(page==1) canvasb.style.display = `flex`;
   if(page==2) canvasc.style.display = `flex`;
}

// Adjust the camera position
camera.position.set(0, 20, 0);
camera.lookAt(0, 0, 0);

// Function to create and animate the mesh
function createAndAnimateMesh() {
 const magnitudeToLightnessExpr = document.getElementById('magnitude-to-lightness').value.trim();
            const colorMode = document.getElementById('color-mode').value;
            const saturationChroma = parseInt(document.getElementById('saturation-chroma').value);
            const lightness = parseInt(document.getElementById('lightness').value);
            const hue = parseInt(document.getElementById('hue').value);

            const funcStr = document.getElementById('function').value.trim();

    // If a previous mesh exists, remove it
    if (mesh) {
        scene.remove(mesh);
        geometry.dispose();
        material.dispose();
    }

    // Create a plane geometry for the mesh
    geometry = new THREE.PlaneGeometry(10, 10, gridSize, gridSize);
    material = new THREE.MeshBasicMaterial({ vertexColors: true, wireframe: false });
    mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Function to update the mesh vertices and colors
    function updateMesh() {
        const positions = geometry.attributes.position.array;
        const numVertices = positions.length / 3;

        const colors = new Float32Array(numVertices * 3);  // Create color array

        for (let i = 0; i < numVertices; i++) {
            const x = positions[i * 3];
            const y = positions[i * 3 + 1];

            // Compute complex number z = x + iy
            let z = math.complex(x, y);
z =  math.evaluate(document.getElementById('function').value, { x: z });
            // Height is the magnitude of z (|z|)
            const zMagnitude = math.abs(z);
			positions[i * 3 + 2] = -zMagnitude;
            positions[i * 3 + 1] = -y;  // Set height to |z|

            // Color based on the argument (arg(z))
            
            const color = complexToColor(math.complex(x, y), z, magnitudeToLightnessExpr, colorMode, saturationChroma, lightness, paletteImageData,0.1, 1);

            // Set color in the array
            colors[i * 3] = color[0] / 255;
            colors[i * 3 + 1] = color[1] / 255;
            colors[i * 3 + 2] = color[2] / 255;
        }

        geometry.attributes.position.needsUpdate = true;  // Notify Three.js that position has changed
        geometry.computeVertexNormals();

        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));  // Apply color array
        geometry.attributes.color.needsUpdate = true;
    }

    // Animate function to continuously update the mesh
    function animateMesh() {
        
        requestAnimationFrame(animateMesh);
        renderer.render(scene, camera);
    }
updateMesh();
    // Start the animation loop
    animateMesh();
}

// Button to create and animate the mesh
document.getElementById('createMeshButton').addEventListener('click', () => {
    createAndAnimateMesh();
});

// WASD and QE camera controls
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let rotateLeft = false, rotateRight = false, rotateUp = false, rotateDown = false, rotateUpc = false, rotateDownc = false,moveUp = false, moveDown = false;
const moveSpeed = 0.1, rotateSpeed = 0.02;

document.addEventListener('keydown', (event) => {
    switch (event.key) {
        case 'w': moveForward = true; break;
        case 's': moveBackward = true; break;
        case 'a': moveLeft = true; break;
        case 'd': moveRight = true; break;
        case 'q': rotateLeft = true; break;
        case 'e': rotateRight = true; break;
		case 'r': rotateUp = true; break;
        case 'f': rotateDown = true; break;
		case 'c': rotateUpc = true; break;
        case 'v': rotateDownc = true; break;
		case 'z': moveUp = true; break;
		case 'x': moveDown = true; break;
    }
});

document.addEventListener('keyup', (event) => {
    switch (event.key) {
        case 'w': moveForward = false; break;
        case 's': moveBackward = false; break;
        case 'a': moveLeft = false; break;
        case 'd': moveRight = false; break;
        case 'q': rotateLeft = false; break;
        case 'e': rotateRight = false; break;
			case 'r': rotateUp = false; break;
        case 'f': rotateDown = false; break;
				case 'c': rotateUpc = false; break;
        case 'v': rotateDownc = false; break;
		case 'z': moveUp = false; break;
		case 'x': moveDown = false; break;
    }
});

function updateCamera() {
    if (moveForward) camera.position.z -= moveSpeed;
    if (moveBackward) camera.position.z += moveSpeed;
    if (moveLeft) camera.position.x -= moveSpeed;
    if (moveRight) camera.position.x += moveSpeed;
	if (moveUp) camera.position.y -= moveSpeed;
    if (moveDown) camera.position.y += moveSpeed;
    if (rotateLeft) camera.rotation.y += rotateSpeed;
    if (rotateRight) camera.rotation.y -= rotateSpeed;
	if (rotateUp) camera.rotation.x += rotateSpeed;
    if (rotateDown) camera.rotation.x -= rotateSpeed;
		if (rotateUpc) camera.rotation.z += rotateSpeed;
    if (rotateDownc) camera.rotation.z -= rotateSpeed;
}

// Animation loop for the camera controls
function animate() {
    requestAnimationFrame(animate);
    updateCamera();
    renderer.render(scene, camera);
}

animate();	
		
		
document.addEventListener('DOMContentLoaded', () => {
    let clickCount = 0;
    let firstPoint = { real: 0, imag: 0 };
    let secondPoint = { real: 0, imag: 0 };
    const container = document.getElementById('coordinate-container');



   




    function initializeCoordinateBoxes() {
        if (!container) {
            console.error('Coordinate container not found');
            return;
        }


        if (container.children.length === 0) {
            const labels = ['Start Real', 'Start Imaginary', 'End Real', 'End Imaginary'];
            labels.forEach(label => {
                const coordBox = document.createElement('div');
                coordBox.classList.add('coordinate-box');

                const pointLabel = document.createElement('label');
                pointLabel.textContent = label + ': ';
                coordBox.appendChild(pointLabel);

            
                const inputBox = document.createElement('input');
                inputBox.type = 'number';
                inputBox.step = 'any';
                inputBox.classList.add(label.includes('Start') ? 'start-input' : 'end-input');
                inputBox.addEventListener('input', updateGraph);
                coordBox.appendChild(inputBox);

                container.appendChild(coordBox);
            });
        }
    }

    function updateGraph() {
        const startInputs = document.querySelectorAll('.start-input');
        const endInputs = document.querySelectorAll('.end-input');

        firstPoint = { real: parseFloat(startInputs[0].value), imag: parseFloat(startInputs[1].value) };
        secondPoint = { real: parseFloat(endInputs[0].value), imag: parseFloat(endInputs[1].value) };

        plotGraph(firstPoint, secondPoint);
    }

    // Event listener for canvas click
    document.getElementById('bmpCanvas').addEventListener('click', function(event) {
        const rect = this.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const canvasWidth = this.width;
        const canvasHeight = this.height;

        const minReal = parseFloat(document.getElementById('min-real').value);
        const maxReal = parseFloat(document.getElementById('max-real').value);
        const minImag = parseFloat(document.getElementById('min-imag').value);
        const maxImag = parseFloat(document.getElementById('max-imag').value);
        const bmpheight = parseFloat(document.getElementById('bmp-height').value);
        const bmpwidth = parseFloat(document.getElementById('bmp-width').value);

        // Convert canvas coordinates to complex plane coordinates
        const real = minReal + (x / (canvasWidth / bmpwidth * 300)) * (maxReal - minReal);
        const imag = minImag + (y / (canvasHeight / bmpheight * 300)) * (maxImag - minImag);


        initializeCoordinateBoxes();

        if (clickCount === 0) {
            document.querySelectorAll('.start-input')[0].value = real;
            document.querySelectorAll('.start-input')[1].value = imag;
            clickCount++;
        } else if (clickCount === 1) {
            document.querySelectorAll('.end-input')[0].value = real;
            document.querySelectorAll('.end-input')[1].value = imag;
            plotGraph(firstPoint, secondPoint);
			updateGraph();
            clickCount = 0;
        }
    });
});

function plotGraph(point1, point2) {
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height); 

    const numSamples = 1000;
    const realValues = [];
    const imagValues = [];
    
 
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (math.min(point1.imag,point2.imag) < 0 && math.max(point1.imag,point2.imag) > 0) {
        const zeroY = (point1.imag)/(point2.imag - point1.imag)*canvas.height+canvas.height;
	
        ctx.strokeStyle = 'DimGray';
        ctx.beginPath();
        ctx.moveTo(canvas.width-zeroY,0);
        ctx.lineTo(canvas.width-zeroY,canvas.height);
        ctx.stroke();
    }
    if (math.min(point1.real,point2.real) < 0 && math.max(point1.real,point2.real) > 0) {
        const zeroY = (point1.real)/(point2.real - point1.real)*canvas.height+canvas.height;
	
        ctx.strokeStyle = 'black' ;
        ctx.beginPath();
        ctx.moveTo(canvas.width-zeroY,0);
        ctx.lineTo(canvas.width-zeroY,canvas.height);
        ctx.stroke();
    }


    for (let i = 0; i <= numSamples; i++) {
        const t = i / numSamples;
        const real = point1.real + t * (point2.real - point1.real);
        const imag = point1.imag + t * (point2.imag - point1.imag);
        
        const z = math.complex(real, imag);
        const fn = math.evaluate(document.getElementById('function').value, { x: z });
        
        realValues.push(fn.re);
        imagValues.push(fn.im);
    }
    

    const graphWidth = canvas.width;
    const graphHeight = canvas.height;
    const maxValue = Math.max(...imagValues, ...realValues);
    const minValue = Math.min(...imagValues, ...realValues);

	if (0>minValue && 0<maxValue) {
        const zeroX = (-minValue)/(maxValue - minValue)*canvas.height;
	
        ctx.strokeStyle = 'black';
        ctx.beginPath();
        ctx.moveTo(0,canvas.height-zeroX);
        ctx.lineTo(canvas.width,canvas.height- zeroX);
        ctx.stroke();
    }

    ctx.beginPath();
    ctx.strokeStyle = 'red';
    for (let i = 0; i < realValues.length; i++) {
        const x = (i / numSamples) * graphWidth;
        const y = graphHeight - ((realValues[i] - minValue) / (maxValue - minValue)) * graphHeight;
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.stroke();


    ctx.beginPath();
    ctx.strokeStyle = 'blue';
    for (let i = 0; i < imagValues.length; i++) {
        const x = (i / numSamples) * graphWidth;
        const y = graphHeight - ((imagValues[i] - minValue) / (maxValue - minValue)) * graphHeight;
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.stroke();
}

        document.getElementById('color-mode').addEventListener('change', function() {
            if (this.value === 'palette') {
                document.getElementById('palette-group').style.display = 'block';
            } else {
                document.getElementById('palette-group').style.display = 'none';
            }
        });

        document.getElementById('palette-file').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        paletteImageData = ctx.getImageData(0, 0, img.width, img.height).data;
                    }
                    img.src = e.target.result;
                }
                reader.readAsDataURL(file);
            }
        });
function generateRandomColor() {

    return '#' + Math.floor(Math.random() * 0xFFFFFF).toString(16).padStart(6, '0');
}

function generatePaletteInputs() {
    const rows = parseInt(document.getElementById('rows').value);
    const columns = parseInt(document.getElementById('columns').value);
    const paletteGenerator = document.getElementById('palette-generator');
    paletteGenerator.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
    paletteGenerator.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
    paletteGenerator.innerHTML = '';
    for (let i = 0; i < rows * columns; i++) {
        const colorInput = document.createElement('input');
        colorInput.type = 'color';
        colorInput.className = 'color-input';
        colorInput.id = `color-${i + 1}`;
        colorInput.value = generateRandomColor();
        paletteGenerator.appendChild(colorInput);
    }
}

function hexToRgb(hex) {
    // Convert a hex color string to an RGB array
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function interpolateColor(rgb1, rgb2, factor) {
    // Interpolate between two RGB colors
    const r = Math.round(rgb1[0] + (rgb2[0] - rgb1[0]) * factor);
    const g = Math.round(rgb1[1] + (rgb2[1] - rgb1[1]) * factor);
    const b = Math.round(rgb1[2] + (rgb2[2] - rgb1[2]) * factor);
    return [r, g, b];
}

function generatePalette() {
    const rows = parseInt(document.getElementById('rows').value);
    const columns = parseInt(document.getElementById('columns').value);
    const colors = [];
    
    for (let i = 1; i <= rows * columns; i++) {
        const colorInput = document.getElementById(`color-${i}`);
        colors.push(colorInput.value);
    }

    // Create a canvas and get its 2D context
    const canvas = document.createElement('canvas');
    canvas.width = 360;
    canvas.height = 100;
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(canvas.width, canvas.height);

    // Calculate dimensions
    const width = canvas.width;
    const height = canvas.height;
    const rowHeight = height / (rows - 1);
    const columnWidth = width / columns;

    // Populate the imageData with gradient colors
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const row = Math.floor(y / rowHeight);
            const column = Math.floor(x / columnWidth);
            const rowFraction = (y % rowHeight) / rowHeight;
            const columnFraction = (x % columnWidth) / columnWidth;
            const color1 = hexToRgb(colors[row * columns + column]);
            const color2 = hexToRgb(colors[row * columns + (column + 1) % columns]);
            const color3 = hexToRgb(colors[(row + 1) % rows * columns + column]);
            const color4 = hexToRgb(colors[(row + 1) % rows * columns + (column + 1) % columns]);

            const colorHorizontal1 = interpolateColor(color1, color2, columnFraction);
            const colorHorizontal2 = interpolateColor(color3, color4, columnFraction);
            const finalColor = interpolateColor(colorHorizontal1, colorHorizontal2, rowFraction);

            const index = ((y -0) * width + x) * 4;
            imageData.data[index] = finalColor[0];     // Red
            imageData.data[index + 1] = finalColor[1]; // Green
            imageData.data[index + 2] = finalColor[2]; // Blue
            imageData.data[index + 3] = 255;           // Alpha
        }
    }

    // Draw the gradient onto the canvas
    ctx.putImageData(imageData, 0, 0);
    
    // Save the image data
    paletteImageData = ctx.getImageData(0, 0, 360, 100).data;

    // For displaying the canvas (optional)
      const existingCanvas = document.querySelector('canvas.preview');
    if (existingCanvas) {
        document.body.removeChild(existingCanvas);
    }
    canvas.className = 'preview'; // Add a class for identifying the preview canvas
    document.body.appendChild(canvas);
}


        function renderBMP() {
		
            const width = parseInt(document.getElementById('bmp-width').value);
            const height = parseInt(document.getElementById('bmp-height').value);
            const minReal = parseFloat(document.getElementById('min-real').value);
            const maxReal = parseFloat(document.getElementById('max-real').value);
            const minImag = parseFloat(document.getElementById('min-imag').value);
            const maxImag = parseFloat(document.getElementById('max-imag').value);
            const magnitudeToLightnessExpr = document.getElementById('magnitude-to-lightness').value.trim();
            const colorMode = document.getElementById('color-mode').value;
            const saturationChroma = parseInt(document.getElementById('saturation-chroma').value);
            const lightness = parseInt(document.getElementById('lightness').value);
            const hue = parseInt(document.getElementById('hue').value);

            const funcStr = document.getElementById('function').value.trim();
            const canvas = document.getElementById('bmpCanvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);

            const reStep = (maxReal - minReal) / width;
            const imStep = (maxImag - minImag) / height;






            for (let x = 0; x < width; x++) {
			let memo = 0;
                for (let y = 0; y < height; y++) {
				 
                    const re = minReal + x * reStep;
                    const im = maxImag - y * imStep;

                    let color = [0, 0, 0];
                    try {
					const complexValue = math.complex(re, im);
                        const funcValue = math.evaluate(funcStr, { x: complexValue });
				//console.log(funcValue);
						color = complexToColor(complexValue, funcValue, magnitudeToLightnessExpr, colorMode, saturationChroma, lightness, paletteImageData,0.1, math.divide(math.subtract(funcValue,memo),imStep));
                memo = funcValue;
				} catch (e) {
                        console.error('Error evaluating function or applying color transformation:', e);
                    }
					
                    const index = (y * width + x) * 4;
                    imageData.data[index] = color[0];
                    imageData.data[index + 1] = color[1];
                    imageData.data[index + 2] = color[2];
                    imageData.data[index + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
			
scaleCanvas();

        }

       

 const canvas = document.getElementById('bmpCanvas');

        const container = document.getElementById('canvasContainer');

        function scaleCanvas() {
            const widthScale = container.clientWidth / (canvas.width);
            const heightScale = container.clientHeight / (canvas.height);
            const scale = Math.min(widthScale, heightScale);
            canvas.style.transform = `scale(${scale})`;
        }


    </script>
</body>
</html>
